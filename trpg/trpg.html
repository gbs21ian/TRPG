<!DOCTYPE html>
<html class="dark" lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini TRPG Control</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Noto+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <script src="https://cdn.socket.io/4.6.0/socket.io.min.js" integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+" crossorigin="anonymous"></script>
  <script id="tailwind-config">
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            "primary": "#3625f4",
            "primary-dark": "#2b1dc2",
            "background-light": "#f6f5f8",
            "background-dark": "#111022",
            "surface-dark": "#1a1a2f",
            "surface-border": "#252249",
            "text-secondary": "#9590cb",
            "input-bg": "#1b1834",
          },
          fontFamily: {
            "display": ["Space Grotesk", "Noto Sans", "sans-serif"],
            "body": ["Noto Sans", "sans-serif"],
          },
          borderRadius: { "DEFAULT": "0.25rem", "lg": "0.5rem", "xl": "0.75rem", "2xl": "1rem", "full": "9999px" },
        },
      },
    }
  </script>
  <style>
    :root { color-scheme: dark; }
    body { font-family: "Space Grotesk", "Noto Sans", system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #111022; }
    ::-webkit-scrollbar-thumb { background: #252249; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #3625f4; }
    .glass-panel {
      background: rgba(26, 26, 32, 0.7);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(54, 37, 244, 0.15);
    }
    .rich-text { white-space: pre-wrap; line-height: 1.7; }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    #chat-log { overflow-x: hidden; }
    #chat-log, #chat-log * { word-break: break-word; overflow-wrap: anywhere; }
    #chat-log pre, #chat-log code { white-space: pre-wrap; word-break: break-word; }
    #chat-log img { max-width: 100%; height: auto; display: inline-block; }
    #chat-log { overscroll-behavior: contain; }
    #chat-log { min-height: 260px; max-height: 60vh; }
    #input-bar { padding-bottom: env(safe-area-inset-bottom); }
    #player-input { overflow-y: auto; }
    #right-aside { height: 100%; min-height: 0; display: flex; flex-direction: column; gap: 16px; }
    /* Mobile momentum scrolling */
    #left-aside, #chat-log, #right-aside { -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
    #dice-panel, #party-stats-panel, #unlimited-panel { overflow-y: auto; }
    #dice-panel { height: 240px; }
    #party-stats-panel { height: auto; overflow-y: visible; }
    #unlimited-panel { height: 160px; }
    /* 3-pane fixed layout */
    main { height: calc(100dvh - 64px); } /* header ~64px */
    #left-aside, #center-pane, #right-aside { height: 100%; min-height: 0; }
    #left-aside { overflow-y: auto; }
    #center-pane { display: flex; flex-direction: column; height: 100%; overflow: hidden; }
    #chat-log { flex: 1; min-height: 0; overflow-y: auto; }
    #input-bar { flex: none; position: static; }
    #right-aside { overflow-y: auto; }
    @media (max-width: 640px) {
      header { padding-left: 12px !important; padding-right: 12px !important; }
      header > div:last-child { flex-wrap: wrap; gap: 8px; }
      #chat-log { padding-left: 12px !important; padding-right: 12px !important; }
      #chat-log { min-height: 220px; max-height: 50vh; }
      #player-input { height: 60px !important; overflow-y: auto; }
      #send-message { padding: 10px 14px !important; }
      #left-aside { max-height: calc(100dvh - 180px); overflow-y: auto; }
      #center-pane { height: calc(100dvh - 180px); }
    }
    #app-version {
      position: fixed;
      bottom: 10px;
      right: 12px;
      z-index: 100;
      font-size: 11px;
      color: #c7c7ff;
      background: rgba(21, 19, 34, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 6px 10px;
      border-radius: 10px;
      pointer-events: none;
    }
  </style>
</head>
<body class="font-display bg-background-light dark:bg-background-dark text-slate-900 dark:text-white min-h-screen overflow-hidden">
    <div class="relative flex min-h-screen flex-col overflow-hidden">
    <div class="pointer-events-none absolute -top-20 -left-20 h-[420px] w-[420px] rounded-full bg-primary/20 blur-[120px]"></div>
    <div class="pointer-events-none absolute -bottom-32 -right-32 h-[520px] w-[520px] rounded-full bg-purple-600/20 blur-[140px]"></div>
    <div class="relative z-10 flex min-h-screen flex-col">
      <header class="flex items-center justify-between border-b border-surface-border bg-surface-dark/60 px-4 py-4 text-white backdrop-blur md:px-10">
        <div class="flex items-center gap-3">
          <div class="flex size-10 items-center justify-center rounded-full bg-primary/20 text-primary">
            <span class="material-symbols-outlined text-3xl">token</span>
          </div>
          <div>
            <h1 class="text-lg font-bold tracking-tight">Gemini TRPG</h1>
            <p class="text-xs text-text-secondary">AI Dice Master Suite</p>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <button class="hidden sm:flex h-10 items-center gap-2 rounded-lg border border-white/10 px-4 text-sm font-semibold text-white transition hover:border-primary hover:text-primary">
            <span class="material-symbols-outlined text-base">description</span>
            문서
          </button>
          <div class="hidden md:flex items-center gap-2 px-3 py-1.5 rounded-full bg-emerald-500/10 border border-emerald-500/20">
            <div class="size-2 rounded-full bg-emerald-500"></div>
            <span class="text-emerald-400 text-xs font-bold uppercase tracking-wider">System Online</span>
          </div>
          <div class="flex gap-2">
            <button class="flex items-center justify-center overflow-hidden rounded-lg h-9 w-9 bg-surface-border hover:bg-primary transition-colors text-white">
              <span class="material-symbols-outlined text-[20px]">wifi</span>
            </button>
            <button class="flex items-center justify-center overflow-hidden rounded-lg h-9 w-9 bg-surface-border hover:bg-primary transition-colors text-white">
              <span class="material-symbols-outlined text-[20px]">settings</span>
            </button>
          </div>
          <button class="flex h-10 items-center gap-2 rounded-lg bg-primary px-4 text-sm font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark">
            <span class="material-symbols-outlined text-base">play_arrow</span>
            미리보기
          </button>
          <button id="btn-save-game" class="hidden h-10 items-center gap-2 rounded-lg border border-white/10 px-4 text-sm font-semibold text-white transition hover:border-emerald-500 hover:text-emerald-400">
            <span class="material-symbols-outlined text-base">save</span>
            저장
          </button>
        </div>
      </header>
      <main class="flex flex-1 flex-col gap-8 px-4 py-6 sm:px-8 lg:px-12">
        <div id="app-version">v26.1.02</div>
        <section id="page-key" class="flex min-h-[calc(100vh-160px)] flex-col items-center justify-center">
          <div class="w-full max-w-4xl glass-panel rounded-3xl p-1 shadow-2xl shadow-black/50">
            <div class="flex flex-col gap-6 rounded-3xl bg-white p-6 text-slate-900 dark:bg-[#151322] dark:text-white sm:p-10">
              <div class="flex flex-col gap-3 text-center sm:text-left">
                <div class="mx-auto inline-flex size-14 items-center justify-center rounded-2xl bg-primary/10 text-primary sm:mx-0">
                  <span class="material-symbols-outlined text-3xl">key</span>
                </div>
                <div>
                  <p class="text-xs font-semibold uppercase tracking-[0.4em] text-primary/70">Arcane Access</p>
                  <h2 class="mt-2 text-3xl font-bold">Gemini API Key로 던전에 입장하세요</h2>
                  <p class="text-sm text-slate-500 dark:text-text-secondary">Google Gemini 또는 OpenAI 키를 기기에 저장해 AI 게임 마스터를 불러옵니다. 키는 로컬에만 보관돼요.</p>
                </div>
              </div>
              <div class="flex items-start gap-3 rounded-2xl border border-blue-500/30 bg-blue-500/10 p-4 text-sm text-blue-100">
                <span class="material-symbols-outlined text-blue-300">shield_lock</span>
                <p>키는 계정 식별용으로 사용되며 서버에 암호화되어 저장됩니다.</p>
              </div>
              <div class="grid gap-4 sm:grid-cols-2">
                <label class="flex flex-col gap-2 text-sm font-semibold text-slate-600 dark:text-gray-300">
                  API 제공자
                  <select id="setup-provider" class="rounded-2xl border border-white/10 bg-input-bg/80 py-3 pl-4 pr-10 text-base text-white focus:border-primary focus:ring-1 focus:ring-primary">
                    <option value="gemini" selected>Gemini</option>
                    <option value="openai">OpenAI</option>
                  </select>
                </label>
                <label class="flex flex-col gap-2 text-sm font-semibold text-slate-600 dark:text-gray-300">
                  API Key
                  <div class="relative">
                    <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-text-secondary">vpn_key</span>
                    <input id="setup-api-key" type="password" autocomplete="off" placeholder="AIza..." class="w-full rounded-2xl border border-white/10 bg-input-bg/80 py-3 pl-11 pr-4 text-base text-white placeholder:text-text-secondary focus:border-primary focus:ring-1 focus:ring-primary" />
                  </div>
                  <span class="text-xs font-normal text-text-secondary">형식은 보통 'AIza' 또는 'sk-'로 시작합니다.</span>
                </label>
              </div>
              <div class="flex flex-wrap items-center gap-4">
                <button type="button" id="enter-lair" class="flex-1 rounded-2xl bg-primary px-6 py-4 text-base font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark">던전에 입장</button>
                <p id="setup-status" class="text-sm text-text-secondary">Gemini 키를 입력하면 다음 페이지에서 게임을 준비할 수 있어요.</p>
              </div>
            </div>
          </div>
        </section>

        <section id="page-saves" class="hidden min-h-[calc(100vh-160px)] flex-col items-center justify-center">
          <div class="w-full max-w-4xl glass-panel rounded-3xl p-1 shadow-2xl shadow-black/50">
            <div class="flex flex-col gap-6 rounded-3xl bg-white p-6 text-slate-900 dark:bg-[#151322] dark:text-white sm:p-10">
              <div class="flex items-center justify-between border-b border-white/10 pb-4">
                <div>
                  <h2 class="text-2xl font-bold">모험 기록</h2>
                  <p class="text-sm text-text-secondary">이전 모험을 불러오거나 새로운 여정을 시작하세요.</p>
                </div>
                <button id="btn-to-lobby" class="rounded-xl bg-primary px-4 py-2 text-sm font-semibold text-white transition hover:bg-primary-dark">새로운 모험 시작</button>
              </div>
              <div id="save-list" class="flex max-h-[400px] flex-col gap-3 overflow-y-auto pr-2">
                <!-- 세이브 슬롯들이 여기에 동적으로 추가됩니다 -->
                <div class="flex items-center justify-center py-10 text-text-secondary">
                  저장된 모험이 없습니다.
                </div>
              </div>
              <div class="flex justify-end pt-2">
                <button id="btn-back-to-key" class="text-sm text-text-secondary hover:text-white">API 키 다시 입력</button>
              </div>
            </div>
          </div>
        </section>

        <section id="page-lobby" class="hidden min-h-[calc(100vh-160px)] flex-col items-center justify-center">
          <div class="w-full max-w-4xl glass-panel rounded-3xl p-1 shadow-2xl shadow-black/50">
            <div class="flex flex-col gap-6 rounded-3xl bg-white p-6 text-slate-900 dark:bg-[#151322] dark:text-white sm:p-10">
              <div class="text-center">
                <h2 class="text-3xl font-bold mb-2">모험 방식 선택</h2>
                <p class="text-sm text-text-secondary">혼자서 이야기를 만들어가거나, 동료들과 함께 모험을 떠나세요.</p>
              </div>
              <div class="grid gap-6 sm:grid-cols-2 mt-4">
                <button id="btn-mode-solo" class="flex flex-col items-center gap-4 rounded-2xl border border-white/10 bg-white/5 p-8 transition hover:border-primary hover:bg-white/10 group">
                  <div class="flex size-20 items-center justify-center rounded-full bg-primary/20 text-primary group-hover:scale-110 transition-transform">
                    <span class="material-symbols-outlined text-4xl">person</span>
                  </div>
                  <div class="text-center">
                    <h3 class="text-xl font-bold text-white mb-1">솔로 플레이</h3>
                    <p class="text-sm text-text-secondary">AI GM과 1:1로 진행하는<br>나만의 서사시</p>
                  </div>
                </button>
                <button id="btn-mode-multi" class="flex flex-col items-center gap-4 rounded-2xl border border-white/10 bg-white/5 p-8 transition hover:border-purple-500 hover:bg-white/10 group">
                  <div class="flex size-20 items-center justify-center rounded-full bg-purple-500/20 text-purple-400 group-hover:scale-110 transition-transform">
                    <span class="material-symbols-outlined text-4xl">groups</span>
                  </div>
                  <div class="text-center">
                    <h3 class="text-xl font-bold text-white mb-1">멀티 플레이</h3>
                    <p class="text-sm text-text-secondary">친구들과 함께 떠나는<br>실시간 파티 모험</p>
                  </div>
                </button>
              </div>
              <div class="flex justify-center pt-4">
                <button id="btn-back-to-saves" class="text-sm text-text-secondary hover:text-white">뒤로 가기</button>
              </div>
            </div>
          </div>
        </section>

        <section id="page-multiplayer" class="hidden min-h-[calc(100vh-160px)] flex-col items-center justify-center">
          <div class="w-full max-w-lg glass-panel rounded-3xl p-1 shadow-2xl shadow-black/50">
            <div class="flex flex-col gap-6 rounded-3xl bg-white p-6 text-slate-900 dark:bg-[#151322] dark:text-white sm:p-10">
              <div class="text-center">
                <h2 class="text-2xl font-bold mb-2">멀티플레이 로비</h2>
                <p class="text-sm text-text-secondary">방을 만들거나 코드를 입력해 참가하세요.</p>
              </div>
              
              <div class="space-y-4">
                <div class="flex flex-col gap-2">
                  <label class="text-sm font-semibold text-white">닉네임</label>
                  <input id="multi-nickname" type="text" placeholder="모험가 이름" class="w-full rounded-2xl border border-white/10 bg-input-bg/80 py-3 px-4 text-base text-white focus:border-primary focus:ring-1 focus:ring-primary" />
                </div>
                
                <div class="border-t border-white/10 my-4"></div>

                <button id="btn-create-room" class="w-full rounded-2xl bg-primary py-3 text-base font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark">
                  방 만들기
                </button>
                
                <div class="relative flex py-2 items-center">
                  <div class="flex-grow border-t border-white/10"></div>
                  <span class="flex-shrink-0 mx-4 text-text-secondary text-xs">또는</span>
                  <div class="flex-grow border-t border-white/10"></div>
                </div>

                <div class="flex gap-2">
                  <input id="room-code-input" type="text" placeholder="참가 코드 입력" class="flex-1 rounded-2xl border border-white/10 bg-input-bg/80 py-3 px-4 text-base text-white uppercase text-center tracking-widest focus:border-purple-500 focus:ring-1 focus:ring-purple-500" maxlength="6" />
                  <button id="btn-join-room" class="rounded-2xl bg-purple-600 px-6 py-3 text-base font-semibold text-white shadow-lg shadow-purple-600/30 transition hover:bg-purple-700">
                    참가
                  </button>
                </div>
              </div>
              
              <div class="flex justify-center pt-2">
                <button id="btn-back-to-lobby" class="text-sm text-text-secondary hover:text-white">뒤로 가기</button>
              </div>
            </div>
          </div>
        </section>

        <section id="page-waiting-room" class="hidden min-h-[calc(100vh-160px)] flex-col items-center justify-center">
          <div class="w-full max-w-4xl glass-panel rounded-3xl p-1 shadow-2xl shadow-black/50">
            <div class="flex flex-col gap-6 rounded-3xl bg-white p-6 text-slate-900 dark:bg-[#151322] dark:text-white sm:p-10">
              <div class="flex items-center justify-between border-b border-white/10 pb-4">
                <div>
                  <h2 class="text-2xl font-bold">대기실</h2>
                  <div class="flex items-center gap-2 mt-1">
                    <span class="text-sm text-text-secondary">초대 코드:</span>
                    <span id="display-room-code" class="text-xl font-mono font-bold text-primary tracking-widest select-all cursor-pointer bg-primary/10 px-2 rounded">------</span>
                  </div>
                </div>
                <div id="host-controls" class="hidden">
                  <button id="btn-start-multi-game" class="rounded-xl bg-emerald-600 px-6 py-2 text-sm font-semibold text-white transition hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed">게임 시작</button>
                </div>
              </div>

              <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="player-list">
                <!-- 플레이어 카드들이 여기에 동적으로 추가됩니다 -->
              </div>

              <div class="flex justify-center pt-4 pb-2">
                <button id="btn-create-character-multi" class="rounded-xl bg-purple-600 px-6 py-2 text-sm font-semibold text-white transition hover:bg-purple-700">캐릭터 생성/수정</button>
              </div>
              
              <div class="flex justify-center pt-4">
                 <button id="btn-leave-room" class="text-sm text-red-400 hover:text-red-300">방 나가기</button>
              </div>
            </div>
          </div>
        </section>

        <section id="page-character" class="hidden min-h-[calc(100vh-160px)] flex-col justify-center">
          <div class="grid gap-6 lg:grid-cols-[320px_1fr]">
            <div class="rounded-3xl border border-surface-border bg-surface-dark/60 p-6 text-white shadow-2xl">
              <p class="text-xs uppercase tracking-[0.4em] text-primary/70">Character Forge</p>
              <h2 class="mt-3 text-3xl font-bold">영웅의 정체성을 설계하세요</h2>
              <p class="mt-2 text-sm text-text-secondary">플레이어 수를 입력하면 자동으로 카드가 생성됩니다. 각 정보는 AI GM에게 공유되어 고유한 개성을 유지합니다.</p>
              <label class="mt-6 flex flex-col gap-2 text-sm font-semibold text-white">
                플레이어 수
                <input id="character-count" type="number" min="1" max="4" value="1" class="rounded-2xl border border-white/20 bg-input-bg/70 py-3 px-4 text-base focus:border-primary focus:ring-1 focus:ring-primary" />
                <span class="text-xs font-normal text-text-secondary">최대 4명까지 한 번에 설정할 수 있습니다.</span>
              </label>
              <div class="mt-6 space-y-3 rounded-2xl border border-white/10 bg-black/30 p-4">
                <p class="text-sm font-semibold text-white">TIP</p>
                <ul class="list-disc space-y-1 pl-5 text-xs text-text-secondary">
                  <li>출신/가치관을 자세히 적을수록 GM 서사가 풍부해집니다.</li>
                </ul>
              </div>
              <button type="button" id="save-character" class="mt-6 w-full rounded-2xl bg-primary py-3 text-base font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark">캐릭터 저장</button>
              <p id="character-status" class="mt-3 text-sm text-text-secondary">필수 항목을 채우고 캐릭터를 저장하세요.</p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-white/5 p-4 sm:p-6 lg:p-8 backdrop-blur scrollbar overflow-y-auto max-h-[calc(100vh-220px)]">
              <form id="character-form" class="flex flex-col gap-5">
                <div id="character-forms" class="space-y-5"></div>
              </form>
            </div>
          </div>
        </section>

        <section id="page-game" class="hidden min-h-[calc(100vh-160px)] flex-col gap-4">
          <div class="flex flex-1 min-h-0 flex-col overflow-hidden rounded-3xl border border-surface-border bg-surface-dark/70 shadow-2xl shadow-black/50">
            <div class="flex flex-1 min-h-0 flex-col lg:flex-row">
              <aside id="left-aside" class="flex w-full flex-col gap-5 border-b border-surface-border bg-black/20 p-5 backdrop-blur lg:w-80 lg:border-b-0 lg:border-r">
                <div id="profile-card" class="rounded-2xl border border-white/10 bg-black/30 p-4">
                  <div class="flex flex-col items-center text-center gap-3">
                    <div class="relative">
                      <div id="profile-image" class="bg-center bg-no-repeat bg-cover rounded-xl h-28 w-28 border-2 border-surface-border shadow-lg shadow-primary/20" style="background-image:url('https://placeholder.pics/svg/120');"></div>
                      <div class="absolute -bottom-2 -right-2 bg-surface-dark border border-surface-border rounded-full p-1.5 text-text-secondary">
                        <span class="material-symbols-outlined text-sm">edit</span>
                      </div>
                    </div>
                    <div class="flex flex-col">
                      <h3 id="profile-name" class="text-white text-base font-bold leading-tight">모험가</h3>
                      <p id="profile-sub" class="text-text-secondary text-xs">Level • Alignment</p>
                    </div>
                  </div>
                </div>
                <div class="rounded-2xl border border-white/10 bg-black/30 p-4" id="self-panel">
                  <div class="flex items-center justify-between text-xs font-semibold text-text-secondary">
                    <span>내 캐릭터</span>
                  </div>
                  <div id="self-info" class="scrollbar mt-3 max-h-56 overflow-y-auto rounded-2xl border border-white/10 bg-black/40 px-4 py-3 text-sm text-slate-200"></div>
                </div>
                <div class="rounded-2xl border border-white/10 bg-black/30 p-4" id="companions-panel">
                  <div class="flex items-center justify-between text-xs font-semibold text-text-secondary">
                    <span>동료 상태</span>
                  </div>
                  <div id="companions-info" class="scrollbar mt-3 max-h-40 overflow-y-auto rounded-2xl border border-white/10 bg-black/40 px-4 py-3 text-sm text-slate-200"></div>
                </div>
                <button id="start-session" class="rounded-2xl bg-primary py-3 text-sm font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark">게임 시작</button>
              </aside>

              <div id="center-pane" class="flex min-h-0 flex-1 flex-col border-surface-border bg-black/30 relative">
                <div id="player-profiles" class="scrollbar hidden flex-shrink-0 gap-4 overflow-x-auto border-b border-surface-border bg-black/30 px-6 py-4"></div>
                <div id="chat-log" class="scrollbar flex-1 min-h-0 space-y-6 overflow-y-auto overflow-x-hidden break-words px-6 py-6 text-base max-w-full"></div>
                <div id="input-bar" class="border-t border-surface-border bg-black/70 p-4 backdrop-blur flex-none">
                 
                  <label for="player-input" class="text-[11px] font-semibold uppercase tracking-wide text-text-secondary">플레이어 행동 입력</label>
                  <div class="mt-2 flex flex-col gap-3 rounded-2xl border border-surface-border bg-surface-dark/70 p-3 shadow-inner shadow-black/40">
                    <textarea id="player-input" rows="3" placeholder="행동, 대사, 주사위 결과 등을 입력하세요." class="h-24 w-full resize-none rounded-2xl border border-white/10 bg-black/30 px-4 py-2 text-base text-white placeholder:text-text-secondary focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary"></textarea>
                    <div class="flex flex-wrap items-center gap-3">
                      <button id="send-message" class="rounded-2xl bg-primary px-6 py-3 text-sm font-semibold text-white shadow-lg shadow-primary/30 transition hover:bg-primary-dark disabled:cursor-not-allowed disabled:opacity-60">전송</button>
                    </div>
                  </div>
                  <p id="status" class="mt-2 text-xs text-text-secondary">API 키를 등록한 뒤 시나리오를 선택하세요.</p>
                </div>
              </div>

              <aside id="right-aside" class="hidden w-80 flex-col gap-4 border-l border-surface-border bg-black/20 p-5 backdrop-blur xl:flex">
                <div class="flex border-b border-surface-border">
                  <button id="tab-btn-log" class="flex-1 py-3 text-sm font-bold text-white border-b-2 border-primary bg-primary/5">Log</button>
                  <button id="tab-btn-inv" class="flex-1 py-3 text-sm font-medium text-text-secondary hover:text-white transition-colors">Inventory</button>
                </div>
                <div id="tab-log" class="rounded-2xl border border-white/10 bg-black/40 p-4">
                  <p class="text-xs text-text-secondary">로그 창</p>
                </div>
                <div id="tab-inventory" class="hidden rounded-2xl border border-white/10 bg-black/40 p-4">
                  <p class="text-xs text-text-secondary">인벤토리 연동 예정</p>
                </div>
                <div class="rounded-2xl border border-white/10 bg-black/40 p-4" id="party-stats-panel">
                  <div class="flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-text-secondary">
                    <span>능력치</span>
                    <span class="text-[10px] text-text-secondary">어려운 성공 시 상승</span>
                  </div>
                  <div id="party-stats" class="mt-3 space-y-3 text-xs text-slate-200"></div>
                </div>
                <!-- Unlimited panel removed -->
                <div id="location-panel" class="p-2 border-t border-surface-border">
                  <p class="text-xs font-bold text-text-secondary uppercase tracking-wider mb-2">Location</p>
                  <div class="relative w-full aspect-video rounded-lg overflow-hidden border border-surface-border group cursor-pointer">
                    <div id="map-image" class="absolute inset-0 bg-cover bg-center transition-transform duration-700 group-hover:scale-110" style="background-image: url('https://placeholder.pics/svg/300');"></div>
                    <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                    <div class="absolute bottom-2 left-3">
                      <p class="text-white text-sm font-bold">Sector</p>
                      <p class="text-[10px] text-text-secondary">Area</p>
                    </div>
                    <div class="absolute top-2 right-2 flex gap-1">
                      
                    </div>
                  </div>
                </div>
              </aside>
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>
<script>
    function resolveBackendURL() {
      const params = new URLSearchParams(window.location.search);
      const fromQuery = params.get("backend");
      if (fromQuery) {
        try { localStorage.setItem("trpg_backend", fromQuery); } catch {}
        return fromQuery;
      }
      try {
        const saved = localStorage.getItem("trpg_backend");
        if (saved) return saved;
      } catch {}
      const host = window.location.hostname || "";
      return host.endsWith(".netlify.app") ? window.location.origin : window.location.origin;
    }
    const BACKEND_URL = resolveBackendURL();
    function chooseTransports() {
      const host = window.location.hostname || "";
      // Netlify는 웹소켓 프록시를 지원하지 않음 → 폴링만 사용
      if (host.endsWith(".netlify.app") && !localStorage.getItem("trpg_backend") && !new URLSearchParams(window.location.search).get("backend")) {
        return ["polling"];
      }
      return ["websocket", "polling"];
    }
    const socket = io(BACKEND_URL, { path: "/socket.io", transports: chooseTransports() });

    const scenarioPool = [
      "황혼이 깔린 디르나 숲. 고대 드루이드의 돌무더기 아래에 봉인된 정령핵을 찾기 위해 3층 깊이의 던전에 잠입한다.",
      "바르모른 항구도시의 지하에서 용병단이 실종됐다. 지하 하수로를 지나 수몰된 성소의 비밀을 밝혀야 한다.",
      "붉은 사막 오아시스에 갑자기 나타난 수정탑. 탑의 각 층은 다른 시공간으로 연결되어 있다.",
      "산성비가 내리는 아이언홀드 폐광. 고블린들이 세계수 뿌리를 훔쳤고, 네 명의 용사가 되찾아야 한다.",
      "얼어붙은 수도원의 지하납골당. 리치가 만든 영혼 수정이 폭주하기 직전이다.",
      "안개가 짙게 드리운 라벤타운. 뱀파이어 가문이 소환식을 준비 중이며, 은촉 성당이 마지막 방어선이다.",
      "거울 호수 아래에 반쯤 잠긴 바실리스크 둥지. 희귀 약초와 독이 공존하는 위험지대다.",
      "천둥전차가 추락한 기계 장벽지대. 톱니 요정과 협상해 방어장치를 되살려야 한다."
    ];
    const diceFaces = ["⚀", "⚁", "⚂", "⚃", "⚄", "⚅"];
    const RACE_AVATAR_MAP = {
      "인간": "/assets/avatars/human.png",
      "엘프": "/assets/avatars/elf.png",
      "하프엘프": "/assets/avatars/half-elf.png",
      "다크엘프": "/assets/avatars/dark-elf.png",
      "드워프": "/assets/avatars/dwarf.png",
      "바바리안": "/assets/avatars/barbarian.png",
      "언데드": "/assets/avatars/undead.png",
      "서큐버스": "/assets/avatars/succubus.png",
      "뱀파이어": "/assets/avatars/vampire.png",
      "웨어비스트": "/assets/avatars/werebeast.png",
      "드래곤본": "/assets/avatars/dragonborn.png",
      "시레나": "/assets/avatars/sirena.png",
    };

    const pageKey = document.getElementById("page-key");
    const pageSaves = document.getElementById("page-saves");
    const pageLobby = document.getElementById("page-lobby");
    const pageMultiplayer = document.getElementById("page-multiplayer");
    const pageWaitingRoom = document.getElementById("page-waiting-room");
    const pageCharacter = document.getElementById("page-character");
    const pageGame = document.getElementById("page-game");
    
    const enterBtn = document.getElementById("enter-lair");
    const setupProvider = document.getElementById("setup-provider");
    const setupApiKey = document.getElementById("setup-api-key");
    const setupStatus = document.getElementById("setup-status");

    const saveList = document.getElementById("save-list");
    const btnToLobby = document.getElementById("btn-to-lobby");
    const btnBackToKey = document.getElementById("btn-back-to-key");
    const btnSaveGame = document.getElementById("btn-save-game");

    const btnModeSolo = document.getElementById("btn-mode-solo");
    const btnModeMulti = document.getElementById("btn-mode-multi");
    const btnBackToSaves = document.getElementById("btn-back-to-saves");

    const multiNickname = document.getElementById("multi-nickname");
    const btnCreateRoom = document.getElementById("btn-create-room");
    const roomCodeInput = document.getElementById("room-code-input");
    const btnJoinRoom = document.getElementById("btn-join-room");
    const btnBackToLobby = document.getElementById("btn-back-to-lobby");

    const displayRoomCode = document.getElementById("display-room-code");
    const playerList = document.getElementById("player-list");
    const hostControls = document.getElementById("host-controls");
    const btnStartMultiGame = document.getElementById("btn-start-multi-game");
    const btnLeaveRoom = document.getElementById("btn-leave-room");

    const connectedProvider = document.getElementById("connected-provider");
    const connectedModel = document.getElementById("connected-model");
    const tabBtnLog = document.getElementById("tab-btn-log");
    const tabBtnInv = document.getElementById("tab-btn-inv");
    const tabLog = document.getElementById("tab-log");
    const tabInv = document.getElementById("tab-inventory");
    const partyStatsPanel = document.getElementById("party-stats-panel");
    const locationPanel = document.getElementById("location-panel");
    const selfPanel = document.getElementById("self-panel");
    const selfInfo = document.getElementById("self-info");
    const companionsPanel = document.getElementById("companions-panel");
    const companionsInfo = document.getElementById("companions-info");
    const partyStats = document.getElementById("party-stats");
    const dicePanel = document.getElementById("dice-panel");
    const startBtn = document.getElementById("start-session");

    const characterCountInput = document.getElementById("character-count");
    const characterFormsWrapper = document.getElementById("character-forms");
    const saveCharacterBtn = document.getElementById("save-character");
    const characterStatus = document.getElementById("character-status");

    const diceVisualA = document.getElementById("dice-visual-a");
    const diceVisualB = document.getElementById("dice-visual-b");
    const diceSummary = document.getElementById("dice-summary");
    const diceLog = document.getElementById("dice-log");

    const chatLog = document.getElementById("chat-log");
    const playerInput = document.getElementById("player-input");
    const sendBtn = document.getElementById("send-message");
    const statusEl = document.getElementById("status");
    const mapImageUrlInput = document.getElementById("map-image-url");
    const btnSetMap = document.getElementById("btn-set-map");
    function showTab(which) {
      const logActive = which === "log";
      const invActive = which === "inv";
      tabLog?.classList.toggle("hidden", !logActive);
      tabInv?.classList.toggle("hidden", !invActive);
      partyStatsPanel?.classList.toggle("hidden", invActive);
      locationPanel?.classList.toggle("hidden", invActive);
      if (tabBtnLog) {
        tabBtnLog.className = logActive
          ? "flex-1 py-3 text-sm font-bold text-white border-b-2 border-primary bg-primary/5"
          : "flex-1 py-3 text-sm font-medium text-text-secondary hover:text-white transition-colors";
      }
      if (tabBtnInv) {
        tabBtnInv.className = invActive
          ? "flex-1 py-3 text-sm font-bold text-white border-b-2 border-primary bg-primary/5"
          : "flex-1 py-3 text-sm font-medium text-text-secondary hover:text-white transition-colors";
      }
    }
    tabBtnLog?.addEventListener("click", () => showTab("log"));
    tabBtnInv?.addEventListener("click", () => showTab("inv"));

    const difficultyTargets = {
      easy: { label: "쉬움", target: 6 },
      standard: { label: "보통", target: 8 },
      hard: { label: "어려움", target: 10 },
      deadly: { label: "치명적", target: 11 }
    };

    const state = {
      mode: 'solo', // 'solo' | 'multi'
      saveId: null, // 현재 로드된 세이브 ID
      history: [],
      provider: "gemini",
      apiKey: "",
      model: "",
      currentScenario: "",
      playerCount: 1,
      characters: [],
      longPrompt: "",
      gmRules: "",
      isBusy: false,
      diceTimer: null,
      
      // Multiplayer State
      roomCode: null,
      preferredRoomCode: null,
      isHost: false,
      nickname: "",
      players: [],
      turnIndex: 0,
      restoringMultiSave: false,
      restorePlayers: [],
      restoreChatHtml: "",
      actionCounts: {},
      lastActionKey: null
    };

    // --- API & Save Logic ---

    async function apiLogin(apiKey) {
      const res = await fetch(`${BACKEND_URL}/api/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ apiKey })
      });
      if (!res.ok) throw new Error('로그인 실패');
      return res.json();
    }

    async function apiSaveGame() {
      if (!state.apiKey) return;
      
      // Determine characters to save
      let charsToSave = state.characters;
      if (state.mode === 'multi' && state.players && state.players.length > 0) {
          charsToSave = state.players.map(p => p.character).filter(Boolean);
      }
      
      const title = charsToSave[0]?.name 
        ? `${charsToSave[0].name}의 모험 (Multi)` 
        : `이름 없는 모험 (${new Date().toLocaleDateString()})`;
        
      const saveData = {
        id: state.saveId || crypto.randomUUID(),
        title: state.mode === 'multi' ? `[멀티] ${title}` : title,
        timestamp: Date.now(),
        provider: state.provider,
        model: state.model,
        history: state.history,
        currentScenario: state.currentScenario,
        playerCount: state.mode === 'multi' ? charsToSave.length : state.playerCount,
        characters: charsToSave,
        mode: state.mode, // Save the mode
        chatHtml: chatLog.innerHTML,
        longPrompt: state.longPrompt,
        stats: state.stats,
        turnIndex: state.turnIndex || 0,
        playing: !!(pageGame && !pageGame.classList.contains("hidden"))
      };
      saveData.mapUrl = state.mapUrl || null;
      if (state.mode === 'multi' && state.roomCode) {
        saveData.roomCode = state.roomCode;
        saveData.players = (state.players || []).map(p => ({
          name: p.name,
          character: p.character,
          spectator: !!p.spectator,
          stats: p.stats || {},
          is_ready: !!p.is_ready
        }));
      }

      try {
        const res = await fetch(`${BACKEND_URL}/api/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ apiKey: state.apiKey, saveData })
        });
        if (!res.ok) throw new Error('저장 실패');
        state.saveId = saveData.id;
        setStatus("게임이 저장되었습니다.");
        alert("저장되었습니다!");
      } catch (e) {
        console.error(e);
        alert("저장 중 오류가 발생했습니다.");
      }
    }

    async function apiDeleteSave(saveId) {
      if (!state.apiKey) return;
      const res = await fetch(`${BACKEND_URL}/api/delete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ apiKey: state.apiKey, saveId })
      });
      if (!res.ok) throw new Error('삭제 실패');
      return res.json();
    }

    function renderSaveList(saves) {
      if (!saves || saves.length === 0) {
        saveList.innerHTML = `
          <div class="flex items-center justify-center py-10 text-text-secondary">
            저장된 모험이 없습니다.
          </div>`;
        return;
      }

      saveList.innerHTML = saves.map(save => {
        const date = new Date(save.timestamp).toLocaleString();
        const isMulti = save.mode === 'multi';
        const codeInfo = isMulti && save.roomCode ? `<span class="text-xs font-mono text-primary bg-primary/10 px-2 py-1 rounded">${save.roomCode}</span>` : `<span class="text-xs text-slate-400">코드 없음</span>`;
        return `
          <div class="flex items-center justify-between rounded-2xl border border-white/10 bg-surface-dark/40 p-4 transition hover:bg-surface-dark/60">
            <div class="flex flex-col gap-1">
              <h3 class="font-bold text-white">${save.title}</h3>
              <p class="text-xs text-text-secondary">${date} · ${save.model} ${isMulti ? '· 멀티' : ''}</p>
              ${isMulti ? `<div class="mt-1 flex items-center gap-2"><span class="text-[11px] text-text-secondary">초대 코드</span>${codeInfo}</div>` : ''}
            </div>
            <div class="flex gap-2">
              <button data-action="load" data-id="${save.id}" onclick="loadGame('${save.id}')" class="rounded-lg bg-primary/20 px-3 py-1.5 text-xs font-semibold text-primary transition hover:bg-primary hover:text-white">불러오기</button>
              ${isMulti ? `<button data-action="load-multi" data-id="${save.id}" onclick="loadGameMulti('${save.id}')" class="rounded-lg bg-purple-600/30 px-3 py-1.5 text-xs font-semibold text-purple-300 transition hover:bg-purple-600 hover:text-white">멀티로 복원</button>` : ''}
              ${isMulti ? `<button data-action="open-waiting" data-id="${save.id}" class="rounded-lg bg-emerald-600/30 px-3 py-1.5 text-xs font-semibold text-emerald-300 transition hover:bg-emerald-600 hover:text-white">대기실 열기</button>` : ''}
              ${isMulti && save.roomCode ? `<button data-action="copy-link" data-id="${save.id}" class="rounded-lg bg-white/10 px-3 py-1.5 text-xs text-white transition hover:bg-white/20">초대 링크 복사</button>` : ''}
              <button data-action="delete" data-id="${save.id}" onclick="deleteGame('${save.id}')" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-rose-400 transition hover:border-rose-400 hover:bg-rose-400/10">삭제</button>
            </div>
          </div>
        `;
      }).join("");

      // 전역 함수로 노출 (HTML onclick에서 접근 가능하도록)
      window.loadGame = (id) => {
        const save = saves.find(s => s.id === id);
        if (save) restoreGame(save);
      };
      
      window.deleteGame = async (id) => {
        if(!confirm("정말 삭제하시겠습니까?")) return;
        try {
          const res = await apiDeleteSave(id);
          renderSaveList(res.saves);
        } catch(e) {
          alert("삭제 실패: " + e.message);
        }
      };
      
      window.loadGameMulti = (id) => {
        const save = saves.find(s => s.id === id);
        if (save) restoreGameMultiplayer(save);
      };
      
      // 안전한 이벤트 위임 (CSP/inline 차단 대비)
      Array.from(saveList.querySelectorAll('button[data-action="load"]')).forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          window.loadGame(id);
        });
      });
      Array.from(saveList.querySelectorAll('button[data-action="load-multi"]')).forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          window.loadGameMulti(id);
        });
      });
      Array.from(saveList.querySelectorAll('button[data-action="open-waiting"]')).forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          const save = saves.find(s => s.id === id);
          if (!save) return;
          restoreGameMultiplayer(save);
          setTimeout(() => {
            const name = multiNickname.value.trim() || "호스트";
            state.nickname = name;
            const code = save.roomCode || undefined;
            socket.emit('create_room', { name, code });
          }, 50);
        });
      });
      Array.from(saveList.querySelectorAll('button[data-action="copy-link"]')).forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          const save = saves.find(s => s.id === id);
          if (!save || !save.roomCode) return;
          const code = save.roomCode.toUpperCase();
          const origin = window.location.origin;
          const link = `${origin}/?room=${code}`;
          try {
            await navigator.clipboard.writeText(link);
            setStatus("초대 링크를 복사했습니다.");
          } catch {
            setStatus("복사 실패. 링크: " + link, true);
          }
        });
      });
      Array.from(saveList.querySelectorAll('button[data-action="delete"]')).forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          await window.deleteGame(id);
        });
      });
    }

    function restoreGame(save) {
      // 상태 복원
      state.saveId = save.id;
      state.provider = save.provider;
      state.model = save.model;
      state.history = save.history || [];
      state.currentScenario = save.currentScenario;
      state.playerCount = save.playerCount;
      state.characters = save.characters;
      state.mode = save.mode || 'solo';
      state.stats = save.stats || {};
      state.longPrompt = save.longPrompt || "";
      
      // UI 복원
      if (connectedProvider) connectedProvider.textContent = state.provider === "gemini" ? "Gemini" : "OpenAI";
      if (connectedModel) connectedModel.textContent = state.model;
      
      // 채팅 로그 복원
      if (save.chatHtml) {
        chatLog.innerHTML = save.chatHtml;
        chatLog.scrollTop = chatLog.scrollHeight;
      } else {
        // chatHtml이 없는 구버전 호환용 (history 기반 재구성 - 텍스트만)
        chatLog.innerHTML = "";
        state.history.forEach(msg => {
          if (msg.role !== 'system') {
            appendChat(msg.role, msg.content);
          }
        });
      }

      // 화면 전환
      pageSaves.classList.add("hidden");
      pageCharacter.classList.add("hidden");
      pageLobby.classList.add("hidden");
      pageGame.classList.remove("hidden");
      btnSaveGame.classList.remove("hidden");
      
      // 주사위/시나리오 패널 상태 (게임 중이므로 주사위 패널 표시)
      showDicePanel(); 
      renderSelfInfo();
      renderPartyStatsPanel();
      updateMapImage();
      setStatus("게임을 불러왔습니다.");
    }

    function restoreGameMultiplayer(save) {
      // 저장 데이터에서 멀티로 복원 준비
      state.saveId = save.id;
      state.provider = save.provider;
      state.model = save.model;
      state.history = save.history || [];
      state.currentScenario = save.currentScenario;
      state.playerCount = save.playerCount;
      state.characters = []; // 멀티에선 개별 캐릭터는 players에서 관리
      state.mode = 'multi';
      state.restoringMultiSave = true;
      state.preferredRoomCode = save.roomCode || null;
      state.restorePlayers = (save.players && Array.isArray(save.players))
        ? save.players.map(p => ({
            name: p.name || (p.character?.name || "플레이어"),
            character: p.character,
            spectator: !!p.spectator,
            stats: p.stats || {},
            is_ready: p.is_ready !== false
          }))
        : (save.characters || []).map((c) => ({
            name: c?.name || "플레이어",
            character: c,
            spectator: false,
            stats: {},
            is_ready: true
          }));
      state.restoreChatHtml = save.chatHtml || "";
      state.restoreTurn = typeof save.turnIndex === "number" ? save.turnIndex : 0;
      state.restorePlaying = !!save.playing;
      state.mapUrl = save.mapUrl || state.mapUrl || null;

      if (connectedProvider) connectedProvider.textContent = state.provider === "gemini" ? "Gemini" : "OpenAI";
      if (connectedModel) connectedModel.textContent = state.model;

      pageSaves.classList.add("hidden");
      pageMultiplayer.classList.remove("hidden");
      multiNickname.value = state.restorePlayers[0]?.name || "호스트";
      setStatus("멀티플레이 복원: 방을 생성하면 대기실에 저장된 파티가 불러와집니다.");
    }
    // --- End Save Logic ---

    function pickScenario() {
      const index = Math.floor(Math.random() * scenarioPool.length);
      return scenarioPool[index];
    }

    function setScenario(text) {
      state.currentScenario = text;
      const el = document.getElementById("scenario-display");
      if (el) el.textContent = text;
    }

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.className = `text-xs ${isError ? "text-rose-300" : "text-slate-400"}`;
    }

    function getLastAssistantContent() {
      for (let i = state.history.length - 1; i >= 0; i--) {
        const m = state.history[i];
        if (m && m.role === "assistant" && typeof m.content === "string") {
          return m.content;
        }
      }
      return "";
    }
    function xpForLevel(level) {
      const L = Math.max(1, Number(level) || 1);
      const n = L - 1;
      return 10 * (n * (n + 1)) / 2;
    }
    function parseXpFromText(text) {
      const t = String(text || "");
      let total = 0;
      const re = /경험치\s*\+?\s*(\d+)/g;
      let m;
      while ((m = re.exec(t)) !== null) {
        const v = Number(m[1] || 0);
        if (!isNaN(v) && v > 0) total += v;
      }
      return total;
    }
    function awardXpExplicit(key, amount) {
      if (!key || !amount || amount <= 0) return;
      ensureSoloStats();
      ensureMultiStats();
      const st = state.stats[key];
      st.xp = (st.xp || 0) + amount;
      while (st.xp >= xpForLevel((st.level || 1) + 1)) {
        st.level = (st.level || 1) + 1;
        levelUpBoostStats(key);
      }
      updateProfileCard();
      renderSelfInfo();
      renderPartyStatsPanel();
      if (state.mode === 'multi') {
        socket.emit('update_stats', { code: state.roomCode, sid: key, stats: st });
      }
    }

    function detectTargetFromText(text) {
      if (!text) return null;
      const m1 = text.match(/목표\s*(\d+)/i);
      if (m1 && m1[1]) return Number(m1[1]);
      const m2 = text.match(/DC\s*(\d+)/i);
      if (m2 && m2[1]) return Number(m2[1]);
      const kwEasy = /(쉬움|간단|간편|사소)/i;
      const kwStd = /(보통|표준)/i;
      const kwHard = /(어려움|위험|복잡|강행|난관)/i;
      const kwDeadly = /(치명|절망|극난)/i;
      if (kwDeadly.test(text)) return 11;
      if (kwHard.test(text)) return 10;
      if (kwStd.test(text)) return 8;
      if (kwEasy.test(text)) return 6;
      return null;
    }

    function mapTargetToKey(t) {
      if (t == null) return "standard";
      if (t <= 6) return "easy";
      if (t <= 8) return "standard";
      if (t <= 10) return "hard";
      return "deadly";
    }

    function autoDetermineDifficulty(content, character) {
      const assistant = getLastAssistantContent();
      let target = detectTargetFromText(assistant);
      if (target == null) target = detectTargetFromText(content);
      if (target == null) target = difficultyTargets.standard.target;
      const s = character?.stats || {};
      function tier(v){ if(!v) return 0; if(v<=4) return -1; if(v>=12) return 2; if(v>=10) return 1; return 0; }
      const tStr = tier(s.str), tDex = tier(s.dex), tInt = tier(s.int), tCha = tier(s.cha), tCon = tier(s.con), tWis = tier(s.wis);
      const txt = (content||"").toLowerCase();
      let action = "general";
      if (/(공격|전투|무기|타격|근접)/i.test(txt)) action = "melee";
      else if (/(활|원거리|사격|투척)/i.test(txt)) action = "ranged";
      else if (/(마법|시전|주문|마도)/i.test(txt)) action = "magic";
      else if (/(생존|회피|기술|잠입|등반|도약|민첩)/i.test(txt)) action = "survival";
      else if (/(설득|협상|위협|기품|교섭|카리스마|친화)/i.test(txt)) action = "social";
      else if (/(직감|지혜|통찰|위험감지|감지)/i.test(txt)) action = "insight";
      let adjust = 0;
      if (action === "melee" || action === "ranged") {
        adjust += Math.max(tStr, tDex);
        const combo = (s.str||0)+(s.dex||0);
        if (combo >= 20) adjust += 2; else if (combo >= 13) adjust += 1;
      } else if (action === "magic") {
        adjust += Math.max(tInt, tCha);
        const combo = (s.cha||0)+(s.wis||0);
        const hasMagic = tInt >= 1 || tCha >= 1;
        if (hasMagic) {
          if (combo >= 20) adjust += 2; else if (combo >= 13) adjust += 1;
        }
      } else if (action === "survival") {
        adjust += Math.max(tDex, tCon);
        const combo = (s.dex||0)+(s.con||0);
        if (combo >= 20) adjust += 2; else if (combo >= 13) adjust += 1;
      } else if (action === "social") {
        adjust += tCha;
      } else if (action === "insight") {
        adjust += tWis;
      } else {
        adjust += Math.max(tStr, tDex, tInt, tCha, tCon, tWis);
      }
      const finalTarget = Math.max(5, Math.min(11, target - Math.max(0, adjust) + (adjust < 0 ? 1 : 0)));
      const key = mapTargetToKey(finalTarget);
      const info = difficultyTargets[key] || difficultyTargets.standard;
      const reason = `행동:${action} | 기준 ${target} → 능력치 보정 ${Math.max(0,adjust)} 적용`;
      return { key, info, target: finalTarget, reason, action };
    }
    function attachStatRollers(index) {
      const base = `char-${index}`;
      const ids = ["str","dex","int","cha","con","wis"];
      ids.forEach(k => {
        const btn = document.getElementById(`${base}-roll-${k}`);
        const out = document.getElementById(`${base}-stat-${k}`);
        if (btn && out) {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            if (btn.disabled) return;
            const a = Math.floor(Math.random()*6)+1;
            const b = Math.floor(Math.random()*6)+1;
            out.value = a + b;
            btn.disabled = true;
            btn.classList.add("opacity-60", "cursor-not-allowed");
            updateAbilityPreview(index);
          });
          if (out.value) {
            btn.disabled = true;
            btn.classList.add("opacity-60", "cursor-not-allowed");
          }
        }
      });
    }
    function updateAbilityPreview(index) {
      const base = `char-${index}`;
      const s = {
        str: Number(document.getElementById(`${base}-stat-str`)?.value)||0,
        dex: Number(document.getElementById(`${base}-stat-dex`)?.value)||0,
        int: Number(document.getElementById(`${base}-stat-int`)?.value)||0,
        cha: Number(document.getElementById(`${base}-stat-cha`)?.value)||0,
        con: Number(document.getElementById(`${base}-stat-con`)?.value)||0,
        wis: Number(document.getElementById(`${base}-stat-wis`)?.value)||0,
      };
      function tier(v){ if(!v) return 0; if(v<=4) return -1; if(v>=12) return 2; if(v>=10) return 1; return 0; }
      const list = [];
      if (tier(s.str) === -1) list.push("약한 근력");
      if (tier(s.dex) === -1) list.push("느릿함");
      if (tier(s.int) === -1) list.push("멍청함");
      if (tier(s.cha) === -1) list.push("미약함");
      if (tier(s.con) === -1) list.push("허약함");
      if (tier(s.wis) === -1) list.push("어리숙함");
      if (tier(s.str) === 1) list.push("괴력+1");
      if (tier(s.str) === 2) list.push("괴력+2");
      if (tier(s.dex) === 1) list.push("체술+1");
      if (tier(s.dex) === 2) list.push("체술+2");
      if (tier(s.int) === 1) list.push("마법시전+1");
      if (tier(s.int) === 2) list.push("마법시전+2");
      if (tier(s.cha) === 1) list.push("마법시전+1");
      if (tier(s.cha) === 2) list.push("마법시전+2");
      if (tier(s.con) >= 1) list.push("피해감소");
      if (tier(s.wis) === 1) list.push("직감+1");
      if (tier(s.wis) === 2) list.push("직감+2");
      const combo1 = (s.str||0)+(s.dex||0);
      if (combo1 >= 20) list.push("무기숙련+2"); else if (combo1 >= 13) list.push("무기숙련+1");
      const combo2 = (s.str||0)+(s.con||0);
      if (combo2 >= 20) list.push("강인함+2"); else if (combo2 >= 13) list.push("강인함+1");
      const combo3 = (s.dex||0)+(s.con||0);
      if (combo3 >= 20) list.push("생존기술+2"); else if (combo3 >= 13) list.push("생존기술+1");
      const combo4 = (s.cha||0)+(s.wis||0);
      const hasMagic = tier(s.int) >= 1 || tier(s.cha) >= 1;
      if (hasMagic) { if (combo4 >= 20) list.push("마법변환+2"); else if (combo4 >= 13) list.push("마법변환+1"); }
      const combo5 = (s.con||0)+(s.wis||0);
      if (combo5 >= 20) list.push("안정감+2"); else if (combo5 >= 13) list.push("안정감+1");
      const el = document.getElementById(`${base}-ability-preview`);
      if (el) el.textContent = list.join(" · ");
    }
    function getStatModifierFromText(text, c) {
      const s = c?.stats || {};
      function tier(v){ if(!v) return 0; if(v<=4) return -1; if(v>=12) return 2; if(v>=10) return 1; return 0; }
      const t = (text||"").toLowerCase();
      let mods = 0;
      if ((s.int || 0) >= 10) mods += 1;
      if (/(공격|전투|무기|타격|근접|원거리)/i.test(t)) {
        mods += Math.max(tier(s.str), tier(s.dex));
        const combo = (s.str||0)+(s.dex||0);
        if (combo >= 20) mods += 2; else if (combo >= 13) mods += 1;
      } else if (/(마법|시전|주문|마도)/i.test(t)) {
        mods += Math.max(tier(s.int), tier(s.cha));
        if ((s.cha||0)+(s.wis||0) >= 20 && (tier(s.int)>=1 || tier(s.cha)>=1)) mods += 2;
        else if ((s.cha||0)+(s.wis||0) >= 13 && (tier(s.int)>=1 || tier(s.cha)>=1)) mods += 1;
      } else if (/(생존|회피|기술|체술|민첩|도약|잠입)/i.test(t)) {
        mods += Math.max(tier(s.dex), tier(s.con));
        const combo = (s.dex||0)+(s.con||0);
        if (combo >= 20) mods += 2; else if (combo >= 13) mods += 1;
      } else if (/(설득|협상|위협|기품|교섭|카리스마)/i.test(t)) {
        mods += tier(s.cha);
      } else if (/(직감|지혜|통찰|위험감지)/i.test(t)) {
        mods += tier(s.wis);
      }
      return mods;
    }


    const MAX_CHARACTERS = 4;

    function setCharacterStatus(message, isError = false) {
      if (!characterStatus) return;
      characterStatus.textContent = message;
      characterStatus.className = `text-sm ${isError ? "text-rose-200" : "text-slate-200"}`;
    }

    function clampCharacterCount(value) {
      return Math.min(MAX_CHARACTERS, Math.max(1, value));
    }

    function createCharacterCard(index) {
      const baseId = `char-${index}`;
      const label = `플레이어 ${index + 1}`;
      return `
        <div class="rounded-3xl border border-white/15 bg-slate-950/60 p-5">
          <div class="mb-4 flex items-center justify-between">
            <p class="text-sm font-semibold text-emerald-300">${label}</p>
            <span class="text-xs text-slate-400">동료와 입장 순서를 맞춰 주세요</span>
          </div>
          <div class="flex flex-col gap-4">
            <div class="grid gap-3 md:grid-cols-2">
              <label class="flex flex-col gap-1.5">
                <span class="text-sm font-medium">캐릭터 이름</span>
                <div class="relative">
                  <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">robot_2</span>
                  <input id="${baseId}-name" type="text" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white placeholder:text-slate-400 focus:border-emerald-400 focus:outline-none" placeholder="예: 린 아르카나" />
                </div>
              </label>
              <label class="flex flex-col gap-1.5">
                <span class="text-sm font-medium">성별</span>
                <div class="relative">
                  <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">transgender</span>
                  <select id="${baseId}-gender" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white focus:border-emerald-400 focus:outline-none">
                    <option value="">선택하세요</option>
                    <option value="남성">남성</option>
                    <option value="여성">여성</option>
                  </select>
                </div>
              </label>
              <label class="flex flex-col gap-1.5">
                <span class="text-sm font-medium">종족</span>
                <div class="relative">
                  <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">groups</span>
                  <select id="${baseId}-race" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white focus:border-emerald-400 focus:outline-none">
                    <option value="">선택하세요</option>
                    <option value="인간">인간</option>
                    <option value="엘프">엘프</option>
                    <option value="하프엘프">하프엘프</option>
                    <option value="다크엘프">다크엘프</option>
                    <option value="드워프">드워프</option>
                    <option value="바바리안">바바리안</option>
                    <option value="언데드">언데드 (고인물 전용)</option>
                    <option value="서큐버스">서큐버스</option>
                    <option value="뱀파이어">뱀파이어</option>
                    <option value="웨어비스트">웨어비스트</option>
                    <option value="드래곤본">드래곤본</option>
                    <option value="시레나">시레나</option>
                    <option value="기타">기타</option>
                  </select>
                </div>
              </label>
            </div>
            <div class="grid gap-3 md:grid-cols-2">
              <label class="flex flex-col gap-1.5">
                <span class="text-sm font-medium">나이</span>
                <div class="relative">
                  <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">cake</span>
                  <input id="${baseId}-age" type="number" min="8" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white placeholder:text-slate-400 focus:border-emerald-400 focus:outline-none" placeholder="숫자로 입력" />
                </div>
              </label>
            </div>
            <label class="flex flex-col gap-1.5">
              <span class="text-sm font-medium">전투 역할 / 클래스</span>
              <div class="relative">
                <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">swords</span>
                <select id="${baseId}-role" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white focus:border-emerald-400 focus:outline-none">
                  <option value="">선택하세요</option>
                  <option value="전사">전사</option>
                  <option value="음유시인">음유시인</option>
                  <option value="성직자">성직자</option>
                  <option value="드루이드">드루이드</option>
                  <option value="무투가">무투가</option>
                  <option value="수도사">수도사</option>
                  <option value="모험가">모험가</option>
                  <option value="궁수">궁수</option>
                  <option value="도적">도적</option>
                  <option value="마법사">마법사</option>
                  <option value="광신도">광신도</option>
                  <option value="기타">기타</option>
                </select>
              </div>
            </label>
            <label class="flex flex-col gap-1.5">
              <span class="text-sm font-medium">출신과 배경</span>
              <div class="relative">
                <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">map</span>
                <textarea id="${baseId}-origin" rows="3" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white placeholder:text-slate-400 focus:border-emerald-400 focus:outline-none" placeholder="예: 황무지 유목민 출신, 사라진 부족을 되찾기 위해 여행 중."></textarea>
              </div>
            </label>
            <label class="flex flex-col gap-1.5">
              <span class="text-sm font-medium">주요 성격 & 가치관</span>
              <div class="relative">
                <span class="material-symbols-outlined pointer-events-none absolute left-3 top-3 text-slate-400">psychiatry</span>
                <textarea id="${baseId}-traits" rows="3" class="w-full rounded-2xl border border-white/20 bg-slate-900/60 py-3 pl-11 pr-4 text-base text-white placeholder:text-slate-400 focus:border-emerald-400 focus:outline-none" placeholder="예: 과감하지만 동료에게 헌신적, 정의감 넘침."></textarea>
              </div>
            </label>
            <div class="mt-2">
              <p class="text-sm font-semibold text-white">능력치 (각 2d6)</p>
              <div class="grid sm:grid-cols-2 gap-2 mt-2">
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">힘</span>
                  <input id="${baseId}-stat-str" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-str" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">민첩</span>
                  <input id="${baseId}-stat-dex" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-dex" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">지능</span>
                  <input id="${baseId}-stat-int" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-int" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">카리스마</span>
                  <input id="${baseId}-stat-cha" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-cha" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">건강</span>
                  <input id="${baseId}-stat-con" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-con" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
                <div class="flex items-center gap-3">
                  <span class="w-16 text-xs text-text-secondary">지혜</span>
                  <input id="${baseId}-stat-wis" type="number" class="w-20 rounded-lg border border-white/20 bg-slate-900/60 py-2 px-3 text-white" readonly />
                  <button type="button" id="${baseId}-roll-wis" class="rounded-lg border border-white/10 px-3 py-1.5 text-xs text-white hover:border-primary hover:text-primary">2d6</button>
                </div>
              </div>
              <div id="${baseId}-ability-preview" class="mt-2 text-[11px] text-text-secondary"></div>
            </div>
          </div>
        </div>
      `;
    }

    function captureCharacterDrafts() {
      const drafts = [];
      const rendered = Number(characterFormsWrapper?.dataset?.count) || 0;
      for (let i = 0; i < rendered; i++) {
        drafts.push({
          name: document.getElementById(`char-${i}-name`)?.value || "",
          gender: document.getElementById(`char-${i}-gender`)?.value || "",
          race: document.getElementById(`char-${i}-race`)?.value || "",
          age: document.getElementById(`char-${i}-age`)?.value || "",
          role: document.getElementById(`char-${i}-role`)?.value || "",
          origin: document.getElementById(`char-${i}-origin`)?.value || "",
          traits: document.getElementById(`char-${i}-traits`)?.value || "",
          stats: {
            str: Number(document.getElementById(`char-${i}-stat-str`)?.value) || 0,
            dex: Number(document.getElementById(`char-${i}-stat-dex`)?.value) || 0,
            int: Number(document.getElementById(`char-${i}-stat-int`)?.value) || 0,
            cha: Number(document.getElementById(`char-${i}-stat-cha`)?.value) || 0,
            con: Number(document.getElementById(`char-${i}-stat-con`)?.value) || 0,
            wis: Number(document.getElementById(`char-${i}-stat-wis`)?.value) || 0,
          },
        });
      }
      return drafts;
    }

    function applyCharacterDrafts(drafts) {
      drafts.forEach((draft, index) => {
        const map = {
          name: `char-${index}-name`,
          gender: `char-${index}-gender`,
          race: `char-${index}-race`,
          age: `char-${index}-age`,
          role: `char-${index}-role`,
          origin: `char-${index}-origin`,
          traits: `char-${index}-traits`,
        };
        Object.entries(map).forEach(([key, id]) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.value = draft?.[key] || "";
        });
        const s = draft?.stats || {};
        const statIds = {
          str: `char-${index}-stat-str`,
          dex: `char-${index}-stat-dex`,
          int: `char-${index}-stat-int`,
          cha: `char-${index}-stat-cha`,
          con: `char-${index}-stat-con`,
          wis: `char-${index}-stat-wis`,
        };
        Object.entries(statIds).forEach(([k, id]) => {
          const el = document.getElementById(id);
          if (el) el.value = s?.[k] || "";
        });
        updateAbilityPreview(index);
      });
    }

    function renderCharacterForms(count) {
      if (!characterFormsWrapper) return;
      const drafts = captureCharacterDrafts();
      const safeCount = clampCharacterCount(Number(count) || 1);
      const cards = [];
      for (let i = 0; i < safeCount; i++) {
        cards.push(createCharacterCard(i));
      }
      characterFormsWrapper.innerHTML = cards.join("");
      characterFormsWrapper.dataset.count = String(safeCount);
      characterCountInput.value = safeCount;
      applyCharacterDrafts(drafts);
      for (let i = 0; i < safeCount; i++) {
        attachStatRollers(i);
      }
      const formEl = document.getElementById("character-form");
      if (formEl) {
        formEl.addEventListener("submit", (e) => e.preventDefault());
      }
    }

    function showScenarioPanel() {
      selfPanel?.classList.remove("hidden");
    }

    function showDicePanel() {
      dicePanel?.classList.remove("hidden");
    }

    function enterCompactMode() {
      // 텍스트 영역 확장만 수행 (패널 유지)
    }

    function updateControlLocks() {
      sendBtn.disabled = state.isBusy;
      playerInput.disabled = state.isBusy;
      playerInput.classList.toggle("opacity-60", state.isBusy);
      playerInput.classList.toggle("cursor-not-allowed", state.isBusy);
      if (startBtn) startBtn.disabled = state.isBusy;
    }

    function setBusyState(value) {
      state.isBusy = value;
      updateControlLocks();
    }

    function requireApiContext() {
      if (!state.apiKey) {
        throw new Error("먼저 Gemini/OpenAI API 키를 등록하세요.");
      }
      return state.apiKey;
    }

    function requireModel() {
      if (!state.model) {
        throw new Error("사용 가능한 모델을 먼저 선택하세요.");
      }
      return state.model;
    }

    function getSystemPrompt(playerCount) {
      let base = `당신은 이 웹 TRPG의 AI 게임 마스터입니다.
플레이어는 총 ${playerCount}명이며, 본 게임의 규칙과 UI를 이해하고 그것에 맞춰 진행합니다.
출력은 반드시 평문으로만 작성하고, 마크다운/특수서식을 사용하지 않습니다.`;
      if (state.longPrompt) base += `\n세계관 및 진행 지침:\n${state.longPrompt}`;
      if (state.gmRules) base += `\nGM 운영 규칙:\n${state.gmRules}`;
      return base;
    }

    function buildCharacterSummary(characters) {
      if (!Array.isArray(characters) || !characters.length) return "";
      return characters
        .map((character, index) => {
          const segments = [
            `플레이어 ${index + 1}`,
            character.name ? `이름: ${character.name}` : "",
            character.gender ? `성별: ${character.gender}` : "",
            character.race ? `종족: ${character.race}` : "",
            character.age ? `나이: ${character.age}` : "",
            character.role ? `역할/클래스: ${character.role}` : "",
            character.origin ? `출신/배경: ${character.origin}` : "",
            character.traits ? `성격/가치관: ${character.traits}` : "",
          ].filter(Boolean);
          return segments.join("\n");
        })
        .join("\n\n");
    }

    function renderSelfInfo() {
      if (!selfInfo) return;
      let content = "";
      if (state.mode === 'multi') {
        const me = state.players.find(p => p.sid === socket.id);
        const c = me?.character || state.characters[0];
        const key = me?.sid || 'solo-0';
        ensureMultiStats();
        if (!state.stats[key]) state.stats[key] = deriveDefaultStats(c || {});
        const st = state.stats[key];
        const level = st.level ?? 1;
        const xp = st.xp ?? 0;
        const prev = xpForLevel(level);
        const next = xpForLevel(level + 1);
        const prog = Math.max(0, Math.min(1, (xp - prev) / Math.max(1, (next - prev))));
        const pct = Math.round(prog * 100);
        if (c) {
          content = `
            <div>
              <p class="text-sm font-semibold text-white">${c.name || "이름 없음"}</p>
              <p class="text-xs text-text-secondary">${c.role || ""} ${c.race ? "· " + c.race : ""} · Lv ${level}</p>
              <div class="mt-2 space-y-1">
                <div class="flex items-center gap-2">
                  <span class="text-[11px] text-rose-300">체력</span>
                  ${renderPips(st.hp, st.hpMax, 'bg-rose-500')}
                </div>
                <div class="flex items-center gap-2">
                  <span class="text-[11px] text-sky-300">정신력</span>
                  ${renderPips(st.sp, st.spMax, 'bg-sky-500')}
                </div>
              </div>
              <div class="mt-1 h-2 w-full rounded bg-white/10 overflow-hidden">
                <div class="h-full bg-primary" style="width:${pct}%;"></div>
              </div>
              <div class="mt-2">
                ${renderStatusBadges(st.status)}
              </div>
              <div class="mt-2 text-[11px] text-text-secondary">인벤토리 슬롯: ${st.inv ?? 5} · 가격 보정: 구매 -${Math.round(((st.buyMod ?? 0)*100))}% · 판매 +${Math.round(((st.sellMod ?? 0)*100))}%</div>
              <div class="mt-2 text-xs whitespace-pre-line">${buildCharacterSummary([c])}</div>
            </div>`;
        } else {
          content = `<p class="text-xs text-text-secondary">캐릭터 정보가 없습니다.</p>`;
        }
      } else {
        const chars = state.characters.length ? state.characters : [];
        ensureSoloStats();
        content = chars.map((c, idx) => {
          const key = `solo-${idx}`;
          if (!state.stats[key]) state.stats[key] = deriveDefaultStats(c);
          const st = state.stats[key];
          const level = st.level ?? 1;
          const xp = st.xp ?? 0;
          const prev = xpForLevel(level);
          const next = xpForLevel(level + 1);
          const prog = Math.max(0, Math.min(1, (xp - prev) / Math.max(1, (next - prev))));
          const pct = Math.round(prog * 100);
          return `
          <div class="mb-3">
            <p class="text-sm font-semibold text-white">${c.name || "이름 없음"}</p>
            <p class="text-xs text-text-secondary">${c.role || ""} ${c.race ? "· " + c.race : ""} · Lv ${level}</p>
            <div class="mt-2 space-y-1">
              <div class="flex items-center gap-2">
                <span class="text-[11px] text-rose-300">체력</span>
                ${renderPips(st.hp, st.hpMax, 'bg-rose-500')}
              </div>
              <div class="flex items-center gap-2">
                <span class="text-[11px] text-sky-300">정신력</span>
                ${renderPips(st.sp, st.spMax, 'bg-sky-500')}
              </div>
            </div>
            <div class="mt-1 h-2 w-full rounded bg-white/10 overflow-hidden">
              <div class="h-full bg-primary" style="width:${pct}%;"></div>
            </div>
            <div class="mt-2">
              ${renderStatusBadges(st.status)}
            </div>
            <div class="mt-2 text-[11px] text-text-secondary">인벤토리 슬롯: ${st.inv ?? 5} · 가격 보정: 구매 -${Math.round(((st.buyMod ?? 0)*100))}% · 판매 +${Math.round(((st.sellMod ?? 0)*100))}%</div>
            <div class="mt-2 text-xs whitespace-pre-line">${buildCharacterSummary([c])}</div>
          </div>`;
        }).join("") || `<p class="text-xs text-text-secondary">캐릭터를 생성하세요.</p>`;
      }
      selfInfo.innerHTML = content;
    }
    function renderPartyStatsPanel() {
      if (!partyStats) return;
      let c = null, key = null;
      if (state.mode === 'multi') {
        const me = state.players.find(p => p.sid === socket.id);
        c = me?.character || null;
        key = me?.sid || null;
        ensureMultiStats();
      } else {
        c = state.characters[0] || null;
        key = 'solo-0';
        ensureSoloStats();
      }
      if (!c) {
        partyStats.innerHTML = `<p class="text-xs text-text-secondary">캐릭터가 없습니다.</p>`;
        return;
      }
      if (!state.stats[key]) state.stats[key] = deriveDefaultStats(c);
      const s = c.stats || {};
      const grid = `
        <div class="grid grid-cols-2 gap-2">
          <div class="flex justify-between"><span>힘</span><span>${s.str ?? "-"}</span></div>
          <div class="flex justify-between"><span>민첩</span><span>${s.dex ?? "-"}</span></div>
          <div class="flex justify-between"><span>지능</span><span>${s.int ?? "-"}</span></div>
          <div class="flex justify-between"><span>카리스마</span><span>${s.cha ?? "-"}</span></div>
          <div class="flex justify-between"><span>건강</span><span>${s.con ?? "-"}</span></div>
          <div class="flex justify-between"><span>지혜</span><span>${s.wis ?? "-"}</span></div>
        </div>
      `;
      partyStats.innerHTML = grid;
    }
    function updateProfileCard() {
      const nameEl = document.getElementById("profile-name");
      const subEl = document.getElementById("profile-sub");
      const imgEl = document.getElementById("profile-image");
      let c = null;
      let levelText = "";
      let key = null;
      if (state.mode === 'multi') {
        const me = state.players.find(p => p.sid === socket.id);
        c = me?.character || null;
        key = me?.sid || null;
      } else {
        c = state.characters[0] || null;
        key = 'solo-0';
      }
      if (key && state.stats && state.stats[key]) {
        const lv = state.stats[key].level || 1;
        levelText = ` · Lv ${lv}`;
      }
      if (nameEl) nameEl.textContent = c?.name || "모험가";
      if (subEl) subEl.textContent = c ? `${c.role || ""}${c.role && c.race ? " · " : ""}${c.race || ""}${levelText}` : "Level • Alignment";
      if (imgEl) {
        const fallback = 'https://placeholder.pics/svg/120';
        const raceUrl = c?.race && RACE_AVATAR_MAP[c.race] ? RACE_AVATAR_MAP[c.race] : null;
        const url = c?.avatarUrl || raceUrl || fallback;
        const tester = new Image();
        tester.onload = () => { imgEl.style.backgroundImage = `url('${url}')`; };
        tester.onerror = () => { imgEl.style.backgroundImage = `url('${fallback}')`; };
        tester.src = url;
      }
    }
    function updateMapImage() {
      const el = document.getElementById("map-image");
      const url = state.mapUrl || 'https://placeholder.pics/svg/300';
      if (el) el.style.backgroundImage = `url('${url}')`;
    }

    function renderCompanionsInfo() {
      if (!companionsInfo || state.mode !== 'multi') {
        companionsPanel?.classList.add("hidden");
        return;
      }
      companionsPanel?.classList.remove("hidden");
      const items = state.players
        .filter(p => p.sid !== socket.id)
        .map(p => {
          const c = p.character || {};
          const key = p.sid || p.name;
          ensureMultiStats();
          if (!state.stats[key]) state.stats[key] = deriveDefaultStats(c);
          const st = state.stats[key];
          return `
            <div class="mb-3">
              <p class="text-sm font-semibold text-white">${p.name}</p>
              <p class="text-xs text-text-secondary">${c.name || "캐릭터 없음"} ${c.role ? "· " + c.role : ""}</p>
              <div class="mt-2 flex items-center gap-3">
                ${renderPips(st.hp, st.hpMax, 'bg-rose-500')}
                ${renderPips(st.sp, st.spMax, 'bg-sky-500')}
              </div>
              <div class="mt-2">
                ${renderStatusBadges(st.status)}
              </div>
            </div>`;
        }).join("");
      companionsInfo.innerHTML = items || `<p class="text-xs text-text-secondary">아직 동료가 없습니다.</p>`;
    }
    function deriveDefaultStats(c) {
      const role = (c?.role || "").toLowerCase();
      const s = c?.stats || {};
      function tier(v) {
        if (!v || v <= 0) return 0;
        if (v <= 4) return -1;
        if (v >= 12) return 2;
        if (v >= 10) return 1;
        return 0;
      }
      let hpMax = Math.floor((s.con || 0) / 3);
      let spMax = Math.floor((s.wis || 0) / 3);
      const tCon = tier(s.con);
      const tWis = tier(s.wis);
      const tCha = tier(s.cha);
      hpMax = Math.max(0, hpMax);
      spMax = Math.max(0, spMax);
      const status = [];
      if (tier(s.str) === -1) status.push("약한 근력");
      if (tier(s.dex) === -1) status.push("느릿함");
      if (tier(s.int) === -1) status.push("멍청함");
      if (tier(s.cha) === -1) status.push("미약함");
      if (tCon === -1) status.push("허약함");
      if (tWis === -1) status.push("어리숙함");
      if (tier(s.str) === 1) status.push("괴력+1");
      if (tier(s.str) === 2) status.push("괴력+2");
      if (tier(s.dex) === 1) status.push("체술+1");
      if (tier(s.dex) === 2) status.push("체술+2");
      if (tier(s.int) === 1) status.push("마법시전+1");
      if (tier(s.int) === 2) status.push("마법시전+2");
      if (tier(s.cha) === 1) status.push("마법시전+1");
      if (tier(s.cha) === 2) status.push("마법시전+2");
      if (tier(s.wis) === 1) status.push("직감+1");
      if (tier(s.wis) === 2) status.push("직감+2");
      const combo1 = (s.str || 0) + (s.dex || 0);
      if (combo1 >= 20) status.push("무기숙련+2");
      else if (combo1 >= 13) status.push("무기숙련+1");
      const combo2 = (s.str || 0) + (s.con || 0);
      if (combo2 >= 20) status.push("강인함+2");
      else if (combo2 >= 13) status.push("강인함+1");
      const combo3 = (s.dex || 0) + (s.con || 0);
      if (combo3 >= 20) status.push("생존기술+2");
      else if (combo3 >= 13) status.push("생존기술+1");
      const combo4 = (s.cha || 0) + (s.wis || 0);
      const hasMagic = tier(s.int) >= 1 || tier(s.cha) >= 1;
      if (hasMagic) {
        if (combo4 >= 20) status.push("마법변환+2");
        else if (combo4 >= 13) status.push("마법변환+1");
      }
      const combo5 = (s.con || 0) + (s.wis || 0);
      if (combo5 >= 20) status.push("안정감+2");
      else if (combo5 >= 13) status.push("안정감+1");
      const invSlots = 5 + Math.floor((s.str || 0) / 3);
      const buyAdj = Math.floor((s.cha || 0) / 10) * 0.10;
      const sellAdj = Math.floor((s.cha || 0) / 10) * 0.10;
      return { hp: hpMax, hpMax, sp: spMax, spMax, status, inv: invSlots, buyMod: buyAdj, sellMod: sellAdj };
    }
    function ensureSoloStats() {
      state.characters.forEach((c, idx) => {
        const key = `solo-${idx}`;
        if (!state.stats[key]) state.stats[key] = deriveDefaultStats(c);
      });
    }
    function ensureMultiStats() {
      (state.players || []).forEach((p) => {
        const key = p.sid || p.name;
        if (!state.stats[key]) state.stats[key] = p.stats || deriveDefaultStats(p.character || {});
      });
    }
    function renderPips(current, max, color) {
      const items = [];
      for (let i = 0; i < max; i++) {
        const filled = i < current;
        items.push(`<span class="inline-block h-3 w-3 rounded-full ${filled ? color : 'bg-transparent border border-white/20'}"></span>`);
      }
      return `<div class="flex gap-1">${items.join("")}</div>`;
    }
    function renderStatusBadges(list) {
      const items = Array.isArray(list) ? list.filter(Boolean) : [];
      if (!items.length) return `<span class="text-[11px] text-text-secondary">상태 없음</span>`;
      return `<div class="flex flex-wrap gap-1">${items.map(s => `<span class="px-2 py-0.5 rounded-full text-[10px] bg-white/10 text-slate-200">${String(s).slice(0,32)}</span>`).join("")}</div>`;
    }
    function detectDamageType(text) {
      const t = (text || "").toLowerCase();
      if (/(공격|전투|타격|부상|넘어짐|추락|칼|창|활|격투|방패|근접|원거리)/i.test(t)) return "hp";
      if (/(공포|정신|혼란|스트레스|위협|환각|저주|설득 실패|협상 실패)/i.test(t)) return "sp";
      return Math.random() < 0.5 ? "hp" : "sp";
    }
    function shouldRoll(content) {
      const t = (content || "").trim().toLowerCase();
      if (!t) return false;
      if (/^([.!?…]+|아+|음+|흠+|하하+|허허+|에[에]*|후우+|헉+|으악+|ㅋ+|ㅠ+|ㅡ+|ㅎ+)+$/.test(t)) return false;
      if (t.length <= 2) return false;
      const actionKeywords = /(공격|전투|회피|도약|잠입|등반|수색|관찰|직감|시전|주문|치유|도주|설득|위협|협상|사격|투척|잠금해제|해킹|끊기|부수기|뜀|당기기|밀기|타격|방어|회복|생존|제거|탈출|돌파|열기|닫기|잡기|던지기|베기|찌르기|응급|첫|행동|시도|판정|굴림)/i;
      const diceKeywords = /(주사위|굴림|roll|d6|판정)/i;
      const hasAction = actionKeywords.test(t) || diceKeywords.test(t);
      return hasAction;
    }
    function computeXpGain(content, success) {
      if (!success) return 0;
      const t = (content || "").toLowerCase();
      if (/(설득|협상|유혹|위협|교섭)/i.test(t)) return 3;
      if (/(공격|전투|타격|격투|사격|투척|처치|제압|승리)/i.test(t)) return 4;
      if (/(시전|주문|마법|탐색|수색|잠입|회피|등반|생존)/i.test(t)) return 3;
      return 2;
    }
    function incrementActionCount(key, action) {
      if (!key || !action) return;
      if (!state.actionCounts[key]) state.actionCounts[key] = {};
      state.actionCounts[key][action] = (state.actionCounts[key][action] || 0) + 1;
    }
    function getCharacterRefByKey(key) {
      if (state.mode === 'multi') {
        const p = (state.players || []).find(x => x.sid === key);
        return p?.character || null;
      } else {
        const idx = key?.startsWith('solo-') ? Number(key.split('-')[1]||'0') : 0;
        return state.characters[idx] || null;
      }
    }
    function levelUpBoostStats(key) {
      const c = getCharacterRefByKey(key);
      if (!c) return;
      c.stats = c.stats || { str:0,dex:0,int:0,cha:0,con:0,wis:0 };
      const counts = state.actionCounts[key] || {};
      const map = {
        melee: ['str','dex'],
        ranged: ['dex','str'],
        magic: ['int','cha'],
        survival: ['dex','con'],
        social: ['cha'],
        insight: ['wis'],
        general: ['str','dex','wis']
      };
      const weights = { str:1, dex:1, int:1, cha:1, con:1, wis:1 };
      Object.entries(counts).forEach(([act, cnt]) => {
        const list = map[act] || [];
        list.forEach(sn => { weights[sn] = (weights[sn] || 0) + cnt; });
      });
      const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
      const topAct = entries.length ? entries[0][0] : 'general';
      (map[topAct] || []).forEach(sn => { weights[sn] += Math.ceil(((counts[topAct]||1))/2); });
      function pickWeighted(w) {
        const keys = Object.keys(w);
        const sum = keys.reduce((acc,k)=>acc+(w[k]||0),0);
        let r = Math.random()*sum;
        for (const k of keys) {
          r -= (w[k]||0);
          if (r <= 0) return k;
        }
        return keys[keys.length-1];
      }
      for (let i=0;i<3;i++) {
        const chosen = pickWeighted(weights);
        c.stats[chosen] = (c.stats[chosen]||0) + 1;
      }
      ensureSoloStats();
      ensureMultiStats();
    }
    function awardXpForAction(key, content, success) {
      if (!key) return;
      ensureSoloStats();
      ensureMultiStats();
      const st = state.stats[key];
      const gain = computeXpGain(content, success);
      st.xp = (st.xp || 0) + gain;
      while (st.xp >= xpForLevel((st.level || 1) + 1)) {
        st.level = (st.level || 1) + 1;
        levelUpBoostStats(key);
      }
      renderSelfInfo();
      renderPartyStatsPanel();
      if (state.mode === 'multi') {
        socket.emit('update_stats', { code: state.roomCode, sid: key, stats: st });
      }
    }
    function applyFailureDamage(contextText) {
      if (state.mode === 'multi') {
        const current = state.players[state.turnIndex];
        const key = current?.sid;
        if (!key) return;
        ensureMultiStats();
        const type = detectDamageType(contextText);
        const st = state.stats[key];
        if (type === "hp" && st.hp > 0) st.hp -= 1;
        if (type === "sp" && st.sp > 0) st.sp -= 1;
        if (st.hp <= 0 || st.sp <= 0) {
          st.hp = Math.max(0, st.hp);
          st.sp = Math.max(0, st.sp);
          st.status = Array.from(new Set([...(st.status || []), "사망", "관전"]));
          socket.emit('set_spectator', { code: state.roomCode, sid: key, reason: type });
        }
        renderSelfInfo();
        renderCompanionsInfo();
        socket.emit('update_stats', { code: state.roomCode, sid: key, stats: st });
      } else {
        ensureSoloStats();
        const key = "solo-0";
        const st = state.stats[key];
        const type = detectDamageType(contextText);
        if (type === "hp" && st.hp > 0) st.hp -= 1;
        if (type === "sp" && st.sp > 0) st.sp -= 1;
        if (st.hp <= 0 || st.sp <= 0) {
          st.hp = Math.max(0, st.hp);
          st.sp = Math.max(0, st.sp);
          st.status = Array.from(new Set([...(st.status || []), "사망"]));
          playerInput.disabled = true;
          sendBtn.disabled = true;
          setStatus("사망했습니다.");
        }
        renderSelfInfo();
      }
    }

    function collectCharacterData() {
      const desiredCount = clampCharacterCount(Number(characterCountInput.value) || 1);
      const characters = [];
      for (let i = 0; i < desiredCount; i++) {
        const prefix = `char-${i}`;
        const name = document.getElementById(`${prefix}-name`)?.value.trim() || "";
        const gender = document.getElementById(`${prefix}-gender`)?.value || "";
        const race = document.getElementById(`${prefix}-race`)?.value || "";
        const age = document.getElementById(`${prefix}-age`)?.value.trim() || "";
        const role = document.getElementById(`${prefix}-role`)?.value || "";
        const origin = document.getElementById(`${prefix}-origin`)?.value.trim() || "";
        const traits = document.getElementById(`${prefix}-traits`)?.value.trim() || "";
        const stats = {
          str: Number(document.getElementById(`${prefix}-stat-str`)?.value) || 0,
          dex: Number(document.getElementById(`${prefix}-stat-dex`)?.value) || 0,
          int: Number(document.getElementById(`${prefix}-stat-int`)?.value) || 0,
          cha: Number(document.getElementById(`${prefix}-stat-cha`)?.value) || 0,
          con: Number(document.getElementById(`${prefix}-stat-con`)?.value) || 0,
          wis: Number(document.getElementById(`${prefix}-stat-wis`)?.value) || 0,
        };

        if (!name) {
          throw new Error(`플레이어 ${i + 1}의 이름을 입력하세요.`);
        }
        if (gender !== "남성" && gender !== "여성") {
          throw new Error(`플레이어 ${i + 1}의 성별은 남성 또는 여성만 선택할 수 있습니다.`);
        }
        if (!race) {
          throw new Error(`플레이어 ${i + 1}의 종족을 선택하세요.`);
        }

        if (!role) {
          throw new Error(`플레이어 ${i + 1}의 전투 역할/클래스를 선택하세요.`);
        }
        if (!origin) {
          throw new Error(`플레이어 ${i + 1}의 출신과 배경을 작성하세요.`);
        }

        characters.push({
          name,
          gender,
          race,
          age,
          role,
          origin,
          traits,
          stats,
        });
      }
      return characters;
    }

    function resetCharacterForm() {
      characterCountInput.value = "1";
      renderCharacterForms(1);
      setCharacterStatus("필수 항목을 채우고 캐릭터를 저장하세요.");
      showScenarioPanel();
    }

    function appendChat(role, text) {
      const isUser = role === "user";
      const wrapper = document.createElement("div");
      wrapper.className = `flex gap-4 max-w-3xl ${isUser ? "flex-row-reverse ml-auto" : ""}`;
      const avatar = document.createElement("div");
      avatar.className = isUser
        ? "flex-none size-10 rounded-full bg-gray-700 bg-center bg-cover"
        : "flex-none size-10 rounded-full bg-gradient-to-br from-primary to-purple-600 flex items-center justify-center";
      if (!isUser) {
        const icon = document.createElement("span");
        icon.className = "material-symbols-outlined text-white text-xl";
        icon.textContent = "smart_toy";
        avatar.appendChild(icon);
      }
      const meta = document.createElement("span");
      meta.className = `${isUser ? "text-text-secondary" : "text-primary"} text-sm font-bold ${isUser ? "mr-1" : "ml-1"}`;
      meta.textContent = isUser ? "You" : "Game Master (AI)";
      const bubble = document.createElement("div");
      bubble.className = isUser
        ? "rich-text bg-primary text-white rounded-2xl rounded-tr-none p-4 shadow-lg shadow-primary/10"
        : "rich-text bg-surface-dark border border-surface-border text-gray-200 rounded-2xl rounded-tl-none p-5 shadow-lg";
      bubble.textContent = isUser ? text : text;
      wrapper.appendChild(avatar);
      const col = document.createElement("div");
      col.className = "flex flex-col gap-1";
      col.appendChild(meta);
      col.appendChild(bubble);
      wrapper.appendChild(col);
      chatLog.appendChild(wrapper);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    let typingEl = null;
    function showTypingIndicator() {
      if (typingEl) return;
      const wrap = document.createElement("div");
      wrap.className = "flex gap-4 max-w-3xl";
      const avatar = document.createElement("div");
      avatar.className = "flex-none size-10 rounded-full bg-gradient-to-br from-primary to-purple-600 flex items-center justify-center";
      const icon = document.createElement("span");
      icon.className = "material-symbols-outlined text-white text-xl";
      icon.textContent = "smart_toy";
      avatar.appendChild(icon);
      const col = document.createElement("div");
      col.className = "flex flex-col gap-1";
      const meta = document.createElement("span");
      meta.className = "text-primary text-sm font-bold ml-1";
      meta.textContent = "Game Master (AI)";
      const box = document.createElement("div");
      box.className = "bg-surface-dark border border-surface-border rounded-2xl rounded-tl-none px-5 py-4 w-24";
      const dots = document.createElement("div");
      dots.className = "flex gap-1.5 items-center h-full";
      ["", "", ""].forEach(() => {
        const d = document.createElement("div");
        d.className = "w-2 h-2 rounded-full bg-text-secondary typing-dot";
        dots.appendChild(d);
      });
      box.appendChild(dots);
      col.appendChild(meta);
      col.appendChild(box);
      wrap.appendChild(avatar);
      wrap.appendChild(col);
      chatLog.appendChild(wrap);
      chatLog.scrollTop = chatLog.scrollHeight;
      typingEl = wrap;
    }
    function hideTypingIndicator() {
      if (typingEl && typingEl.parentNode) {
        typingEl.parentNode.removeChild(typingEl);
      }
      typingEl = null;
    }

    function logDiceResult(roll) {
      const difficultyInfo = difficultyTargets[roll.difficulty] || difficultyTargets.standard;
      const outcome = roll.total >= difficultyInfo.target ? "성공" : "실패";
      // 스타일 카드로 채팅에 시스템 판정 표시
      const card = document.createElement("div");
      card.className = "flex justify-center my-4";
      const inner = document.createElement("div");
      inner.className = `flex items-center gap-4 bg-surface-dark border border-surface-border px-6 py-3 rounded-lg shadow-xl relative overflow-hidden`;
      const stripe = document.createElement("div");
      stripe.className = `absolute left-0 top-0 bottom-0 w-1 ${outcome === "성공" ? "bg-emerald-500" : "bg-rose-500"}`;
      const icon = document.createElement("span");
      icon.className = `${outcome === "성공" ? "text-emerald-500" : "text-rose-500"} material-symbols-outlined text-2xl`;
      icon.textContent = "casino";
      const infoBox = document.createElement("div");
      infoBox.className = "flex flex-col";
      const title = document.createElement("span");
      title.className = "text-[10px] uppercase font-bold text-text-secondary tracking-widest";
      title.textContent = `${difficultyInfo.label} (DC ${difficultyInfo.target})`;
      const valueRow = document.createElement("div");
      valueRow.className = "flex items-baseline gap-2";
      const val = document.createElement("span");
      val.className = "text-white font-bold text-xl";
      val.textContent = String(roll.total);
      const tag = document.createElement("span");
      tag.className = `${outcome === "성공" ? "text-emerald-400" : "text-rose-400"} text-xs font-bold`;
      tag.textContent = outcome === "성공" ? "(Success)" : "(Failure)";
      valueRow.appendChild(val);
      valueRow.appendChild(tag);
      infoBox.appendChild(title);
      infoBox.appendChild(valueRow);
      const dcSep = document.createElement("div");
      dcSep.className = "h-8 w-px bg-surface-border mx-2";
      const dcText = document.createElement("span");
      dcText.className = "text-text-secondary text-sm";
      dcText.textContent = `DC ${difficultyInfo.target}`;
      inner.appendChild(stripe);
      inner.appendChild(icon);
      inner.appendChild(infoBox);
      inner.appendChild(dcSep);
      inner.appendChild(dcText);
      card.appendChild(inner);
      chatLog.appendChild(card);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function rollDiceWithAnimation(difficultyKey = "standard") {
      return new Promise((resolve) => {
        if (state.diceTimer) {
          clearInterval(state.diceTimer);
          state.diceTimer = null;
        }
        let frame = 0;
        const animation = setInterval(() => {
          const faceA = diceFaces[frame % diceFaces.length];
          const faceB = diceFaces[(frame + 2) % diceFaces.length];
          if (diceVisualA) diceVisualA.textContent = faceA;
          if (diceVisualB) diceVisualB.textContent = faceB;
          frame += 1;
        }, 90);
        state.diceTimer = animation;
        setStatus("주사위가 굴러가는 중입니다...");
        setTimeout(() => {
          clearInterval(animation);
          state.diceTimer = null;
          const first = Math.floor(Math.random() * 6) + 1;
          const second = Math.floor(Math.random() * 6) + 1;
          const total = first + second;
          if (diceVisualA) diceVisualA.textContent = diceFaces[first - 1];
          if (diceVisualB) diceVisualB.textContent = diceFaces[second - 1];
          const roll = { first, second, total, difficulty: difficultyKey };
          logDiceResult(roll);
          setStatus("주사위 결과가 기록되었습니다.");
          resolve(roll);
        }, 900);
      });
    }

    function makeGeminiBody(messages) {
      const contents = [];
      const systemParts = [];
      messages.forEach((msg) => {
        if (msg.role === "system") {
          systemParts.push(msg.content);
          return;
        }
        contents.push({
          role: msg.role === "assistant" ? "model" : "user",
          parts: [{ text: msg.content }],
        });
      });
      if (systemParts.length) {
        contents.unshift({
          role: "user",
          parts: [{ text: `게임 마스터 지침:\n${systemParts.join("\n")}` }],
        });
      }
      return { contents };
    }

    async function requestOpenAI(messages, model, apiKey) {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ model, messages, temperature: 0.9 }),
      });
      if (!response.ok) {
        throw new Error(`OpenAI 오류: ${response.status}`);
      }
      const data = await response.json();
      return data.choices?.[0]?.message?.content?.trim() || "응답이 없습니다.";
    }

    const GEMINI_VERSION_PATH = "v1beta";

    async function listGeminiModels(apiKey) {
      const response = await fetch(`https://generativelanguage.googleapis.com/${GEMINI_VERSION_PATH}/models?key=${apiKey}`);
      const raw = await response.text();
      if (!response.ok) {
        throw new Error(`모델 목록을 불러올 수 없습니다: ${raw}`);
      }
      const data = JSON.parse(raw);
      return (data.models || [])
        .map((model) => model.name?.replace(/^models\//, ""))
        .filter(Boolean);
    }

    async function requestGemini(messages, model, apiKey) {
      const response = await fetch(`https://generativelanguage.googleapis.com/${GEMINI_VERSION_PATH}/models/${encodeURIComponent(model)}:generateContent?key=${apiKey}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...makeGeminiBody(messages),
          generationConfig: { temperature: 0.9 },
        }),
      });
      const rawText = await response.text();
      if (!response.ok) {
        throw new Error(`Gemini 오류 ${response.status}: ${rawText}`);
      }
      const data = JSON.parse(rawText);
      const parts = data.candidates?.[0]?.content?.parts || [];
      return parts.map((part) => part.text || "").join("").trim() || "응답이 없습니다.";
    }

    async function sendToModel(userText) {
      const apiKey = requireApiContext();
      const model = requireModel();
      const provider = state.provider;
      const payloadMessages = [...state.history, { role: "user", content: userText }];

      setBusyState(true);
      setStatus("GM이 답변을 준비 중입니다...");
      showTypingIndicator();

      try {
        const reply = provider === "gemini"
          ? await requestGemini(payloadMessages, model, apiKey)
          : await requestOpenAI(payloadMessages, model, apiKey);

        const clean = (reply || "").replace(/\*\*/g, "");
        state.history = [...payloadMessages, { role: "assistant", content: clean }];
        hideTypingIndicator();
        appendChat("assistant", clean);
        setStatus("턴이 종료되었습니다. 다음 행동을 입력하세요.");
      } catch (error) {
        console.error(error);
        setStatus(error.message, true);
      } finally {
        hideTypingIndicator();
        setBusyState(false);
      }
    }

    function startSession(autoRoll = false) {
      try {
        requireApiContext();
        requireModel();
      } catch (error) {
        setStatus(error.message, true);
        return;
      }

      if (!state.characters.length) {
        setStatus("캐릭터 정보를 먼저 저장하세요.", true);
        return;
      }

      const scenario = state.currentScenario || (state.longPrompt ? "프롬프트 기반 시나리오" : "기본 시나리오");
      const playerCount = Math.min(6, Math.max(1, state.characters.length || 1));
      state.playerCount = playerCount;
      const characterSummary = buildCharacterSummary(state.characters);

      chatLog.innerHTML = "";
      const systemPrompt = getSystemPrompt(playerCount);
      state.history = [{ role: "system", content: systemPrompt }];
      if (characterSummary) {
        state.history.push({ role: "user", content: `플레이어 캐릭터 정보:\n${characterSummary}` });
        appendChat("user", `캐릭터 프로필\n${characterSummary}`);
      }
      state.history.push({ role: "user", content: `게임에 사용할 시나리오:\n${scenario}` });

      const opening = `플레이어 ${playerCount}명 기준으로 아래 시나리오와 캐릭터 정보를 반영해 첫 장면을 전개해 주세요.\n${scenario}`;
      appendChat("user", opening);
      playerInput.value = "";
      setStatus("게임이 시작되었습니다. 첫 장면을 불러오는 중...");
      sendToModel("위 캐릭터와 시나리오를 기준으로 게임을 시작하고 첫 장면과 선택지를 제시하세요.");

      // UI 패널 표시
      if (startBtn) startBtn.classList.add("hidden");
      updateProfileCard();
      ensureSoloStats();
      renderSelfInfo();
      renderPartyStatsPanel();
      renderCompanionsInfo();
      renderSelfInfo();
      enterCompactMode();
      if (autoRoll) {
        rollDiceWithAnimation("standard");
      }
    }

    enterBtn.addEventListener("click", async () => {
      const provider = setupProvider.value;
      const apiKey = setupApiKey.value.trim();
      if (!apiKey) {
        setupStatus.textContent = "API 키를 입력하세요.";
        setupStatus.className = "text-xs text-rose-300";
        return;
      }
      enterBtn.disabled = true;
      setupStatus.textContent = "키를 확인하는 중...";
      setupStatus.className = "text-xs text-slate-300";
      let resolvedModel = provider === "gemini" ? "gemini-1.5-flash" : "gpt-4o-mini";
      if (provider === "gemini") {
        try {
          const models = await listGeminiModels(apiKey);
          if (models.length) {
            const preferred = models.find((name) => name.includes("1.5"));
            resolvedModel = preferred || models[0];
          }
          setupStatus.textContent = `모델 ${resolvedModel}이(가) 사용 가능합니다.`;
          setupStatus.className = "text-xs text-emerald-300";
        } catch (error) {
          console.error(error);
          setupStatus.textContent = error.message;
          setupStatus.className = "text-xs text-rose-300";
          enterBtn.disabled = false;
          return;
        }
      } else {
        setupStatus.textContent = "키가 저장되었습니다.";
        setupStatus.className = "text-xs text-emerald-300";
      }
      state.provider = provider;
      state.apiKey = apiKey;
      state.model = resolvedModel;
      if (connectedProvider) connectedProvider.textContent = provider === "gemini" ? "Gemini" : "OpenAI";
      if (connectedModel) connectedModel.textContent = resolvedModel;
      setupApiKey.value = "";
      // API 키가 확인되면 항상 모험 기록으로 이동
      let savesData = { saves: [] };
      try {
        savesData = await apiLogin(apiKey);
      } catch (e) {
        console.error("Login/Load error:", e);
      }
      pageKey.classList.add("hidden");
      pageLobby.classList.add("hidden");
      pageCharacter.classList.add("hidden");
      pageGame.classList.add("hidden");
      pageSaves.classList.remove("hidden");
      renderSaveList(savesData?.saves || []);
      enterBtn.disabled = false;
    });

    // btnNewGame listener removed (replaced by Lobby flow)


    btnBackToKey.addEventListener("click", () => {
      pageSaves.classList.add("hidden");
      pageKey.classList.remove("hidden");
      state.apiKey = "";
      setupApiKey.value = "";
    });
    
    btnSaveGame.addEventListener("click", apiSaveGame);
    (async () => {
      try {
        const res = await fetch('/prompts/world.md');
        if (res.ok) {
          const text = (await res.text()).trim();
          state.longPrompt = text;
        }
      } catch {}
      try {
        const res2 = await fetch('/prompts/gm_rules.md');
        if (res2.ok) {
          const text2 = (await res2.text()).trim();
          state.gmRules = text2;
        }
      } catch {}
      // URL로 방 자동 참가 지원 (?room=CODE)
      try {
        const params = new URLSearchParams(window.location.search);
        const room = params.get('room');
        const name = params.get('name') || "익명";
        if (room) {
          state.mode = 'multi';
          pageKey.classList.add("hidden");
          pageLobby.classList.add("hidden");
          pageMultiplayer.classList.remove("hidden");
          multiNickname.value = name;
          roomCodeInput.value = room.toUpperCase();
          btnJoinRoom.click();
        }
      } catch {}
    })();

    saveCharacterBtn.addEventListener("click", () => {
      try {
        const characters = collectCharacterData();
        state.characters = characters;
        updateProfileCard();

        if (state.mode === 'multi') {
            socket.emit('update_character', { code: state.roomCode, character: characters[0] });
            pageCharacter.classList.add("hidden");
            pageWaitingRoom.classList.remove("hidden");
            renderSelfInfo();
            renderPartyStatsPanel();
            return;
        }

        state.playerCount = characters.length;
        setCharacterStatus("캐릭터가 저장되었습니다. 시나리오를 선택해 주세요.");
        pageCharacter.classList.add("hidden");
        pageGame.classList.remove("hidden");
        btnSaveGame.classList.remove("hidden"); // 저장 버튼 표시
        setStatus("랜덤 시나리오를 확인하고 '시작'을 누르세요.");
        ensureSoloStats();
        renderSelfInfo();
        renderPartyStatsPanel();
        renderCompanionsInfo();
      } catch (error) {
        setCharacterStatus(error.message, true);
      }
    });
    if (btnSetMap && mapImageUrlInput) {
      btnSetMap.addEventListener("click", () => {
        const url = mapImageUrlInput.value.trim();
        if (!url) return;
        state.mapUrl = url;
        updateMapImage();
      });
    }

    const handleCharacterCountInput = () => {
      const desired = clampCharacterCount(Number(characterCountInput.value) || 1);
      renderCharacterForms(desired);
      setCharacterStatus("필수 항목을 채우고 캐릭터를 저장하세요.");
    };

    characterCountInput.addEventListener("change", handleCharacterCountInput);
    characterCountInput.addEventListener("input", handleCharacterCountInput);

    startBtn.addEventListener("click", () => startSession(false));
    // 랜덤 시나리오 UI 제거

    sendBtn.addEventListener("click", async () => {
      if (state.isBusy || state.diceTimer) return;
      try {
        requireApiContext();
        requireModel();
      } catch (e) {
        setStatus(e.message, true);
        return;
      }
      const content = playerInput.value.trim();
      if (!content) {
        setStatus("행동 또는 주사위 판정 내용을 입력하세요.", true);
        return;
      }
      let currentChar = null;
      if (state.mode === 'multi') {
        currentChar = state.players[state.turnIndex]?.character || null;
      } else {
        currentChar = state.characters[0] || null;
      }
      let fullMessage = content;
      if (shouldRoll(content)) {
        const auto = autoDetermineDifficulty(content, currentChar);
        const difficultyKey = auto.key;
        const keyForCount = state.mode === 'multi' ? (state.players[state.turnIndex]?.sid || null) : 'solo-0';
        state.lastActionKey = keyForCount;
        if (keyForCount) incrementActionCount(keyForCount, auto.action);
        const roll = await rollDiceWithAnimation(difficultyKey).catch(() => ({
          first: 1,
          second: 1,
          total: 2,
          difficulty: difficultyKey
        }));
        const info = auto.info;
        const target = auto.target;
        const statMod = getStatModifierFromText(content, currentChar);
        const totalWithMod = roll.total + Math.max(0, statMod);
        const outcome = totalWithMod >= target ? "성공" : "실패";
        const modText = statMod ? ` + 보정 ${Math.max(0,statMod)}` : "";
        const diceNote = `\n\n[자동 판정]\n난이도 ${info.label} (목표 ${target})\n주사위: ${roll.first} + ${roll.second} = ${roll.total}${modText} → ${outcome}`;
        fullMessage = `${content}${diceNote}`;
        if (outcome === "실패") {
          applyFailureDamage(content);
        }
        if (outcome === "성공" && keyForCount) {
          awardXpForAction(keyForCount, content, true);
        }
      }

      playerInput.value = "";

      if (state.mode === 'multi') {
          const currentPlayer = state.players[state.turnIndex];
          if (currentPlayer && (currentPlayer.sid !== socket.id || currentPlayer.spectator)) {
              alert("당신의 턴이 아닙니다!");
              return;
          }
          socket.emit('send_action', { 
              code: state.roomCode, 
              content: fullMessage, 
              sender: state.nickname 
          });
      } else {
          appendChat("user", fullMessage);
          sendToModel(fullMessage);
      }
    });

    playerInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendBtn.click();
      }
    });

    // --- Multiplayer Navigation & Logic ---

    const btnCreateCharacterMulti = document.getElementById("btn-create-character-multi");

    // Lobby Navigation
    if(btnToLobby) {
        btnToLobby.addEventListener("click", () => {
            pageSaves.classList.add("hidden");
            pageLobby.classList.remove("hidden");
        });
    }

    if(btnBackToSaves) {
        btnBackToSaves.addEventListener("click", () => {
            pageLobby.classList.add("hidden");
            pageSaves.classList.remove("hidden");
        });
    }

    btnModeSolo.addEventListener("click", () => {
        state.mode = 'solo';
        pageLobby.classList.add("hidden");
        pageCharacter.classList.remove("hidden");
        state.saveId = null;
        state.characters = [];
        resetCharacterForm();
        // Solo mode character count enabled
        characterCountInput.disabled = false; 
    });

    btnModeMulti.addEventListener("click", () => {
        state.mode = 'multi';
        pageLobby.classList.add("hidden");
        pageMultiplayer.classList.remove("hidden");
    });

    btnBackToLobby.addEventListener("click", () => {
        pageMultiplayer.classList.add("hidden");
        pageLobby.classList.remove("hidden");
    });

    // Room Creation / Joining
    btnCreateRoom.addEventListener("click", () => {
        const name = multiNickname.value.trim() || "익명";
        state.nickname = name;
        const code = state.preferredRoomCode || undefined;
        socket.emit('create_room', { name, code });
    });

    btnJoinRoom.addEventListener("click", () => {
        const name = multiNickname.value.trim() || "익명";
        const code = roomCodeInput.value.trim().toUpperCase();
        if (!code) {
            alert("방 코드를 입력하세요.");
            return;
        }
        state.nickname = name;
        state.roomCode = code; // Optimistically set code
        socket.emit('join_room', { code, name });
    });

    btnLeaveRoom.addEventListener("click", () => {
        try { socket.disconnect(); } catch {}
        state.roomCode = null;
        state.players = [];
        state.isHost = false;
        pageWaitingRoom.classList.add("hidden");
        pageMultiplayer.classList.add("hidden");
        pageLobby.classList.remove("hidden");
        setStatus("방에서 나왔습니다.");
    });

    // Waiting Room Logic
    if (btnCreateCharacterMulti) {
        btnCreateCharacterMulti.addEventListener("click", () => {
            pageWaitingRoom.classList.add("hidden");
            pageCharacter.classList.remove("hidden");
            // Force 1 player for self in multiplayer
            characterCountInput.value = 1;
            characterCountInput.disabled = true;
            renderCharacterForms(1);
            setCharacterStatus("캐릭터를 생성하고 저장하면 대기실로 돌아갑니다.");
        });
    }

    // Start Game (Host)
    btnStartMultiGame.addEventListener("click", () => {
        if(!state.isHost) return;
        socket.emit('start_game', { code: state.roomCode });
    });

    // --- Socket Events ---

    socket.on('room_created', (data) => {
        state.roomCode = data.code;
        state.isHost = true;
        state.players = data.players;
        enterWaitingRoom();
        if (state.restoringMultiSave) {
            const restored = state.restorePlayers.map(p => ({
                name: p.name,
                character: p.character,
                spectator: !!p.spectator,
                stats: p.stats || {},
                is_ready: p.is_ready !== false
            }));
            socket.emit('restore_room', { 
                code: state.roomCode, 
                players: restored, 
                turn_index: state.restoreTurn || 0, 
                chat_html: state.restoreChatHtml,
                start_playing: !!state.restorePlaying
            });
            state.restoringMultiSave = false;
            state.restoredStartPlaying = !!state.restorePlaying;
        }
    });

    socket.on('player_joined', (data) => {
        // If I am the one who joined, I need to know.
        const me = data.players.find(p => p.sid === socket.id);
        if (me) {
             state.isHost = false; 
             enterWaitingRoom();
        }
        state.players = data.players;
        renderPlayerList();
    });

    socket.on('player_updated', (data) => {
        state.players = data.players;
        renderPlayerList();
        renderCompanionsInfo();
    });
    socket.on('stats_updated', (data) => {
        state.players = data.players;
        ensureMultiStats();
        (data.players || []).forEach(p => {
          const sid = p.sid;
          if (!sid) return;
          state.stats[sid] = {
            ...(state.stats[sid] || deriveDefaultStats(p.character || {})),
            ...(p.stats || {})
          };
        });
        updateProfileCard();
        renderSelfInfo();
        renderPartyStatsPanel();
        renderCompanionsInfo();
    });

    socket.on('player_left', (data) => {
        state.players = data.players;
        renderPlayerList();
        renderCompanionsInfo();
        if (state.players.length > 0 && state.players[0].sid === socket.id) {
            state.isHost = true;
            hostControls.classList.remove("hidden");
            if (!pageGame.classList.contains("hidden")) {
                btnSaveGame.classList.remove("hidden");
            }
        }
    });

    socket.on('sync_history', (data) => {
        const html = data?.chat_html || "";
        if (html) {
            chatLog.innerHTML = html;
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    });

    socket.on('game_started', (data) => {
        state.turnIndex = data.turn_index;
        pageWaitingRoom.classList.add("hidden");
        pageGame.classList.remove("hidden");
        
        updateProfileCard();
        renderSelfInfo();
        renderPartyStatsPanel();
        renderCompanionsInfo();
        enterCompactMode();
        updateControlLocks();
        setStatus("멀티플레이 게임이 시작되었습니다!");
        if (startBtn) startBtn.classList.add("hidden");
        
        if (state.isHost) {
            if (!state.restoredStartPlaying) {
                startMultiplayerSession();
            } else {
                state.restoredStartPlaying = false;
            }
            btnSaveGame.classList.remove("hidden");
        } else {
            btnSaveGame.classList.add("hidden");
        }
    });
    
    socket.on('new_message', (data) => {
        appendChat(data.sender === "GM" ? "assistant" : "user", data.content);
        if (data.sender === "GM") {
          const amount = parseXpFromText(data.content);
          if (amount > 0) {
            const key = state.mode === 'multi'
              ? (state.lastActionKey || (state.players[state.turnIndex]?.sid || null))
              : 'solo-0';
            awardXpExplicit(key, amount);
          }
        }
        if (data.type === 'user' && state.isHost) {
             handleMultiplayerGM(data.content, data.sender);
        }
    });
    
    socket.on('turn_changed', (data) => {
        state.turnIndex = data.turn_index;
        const currentPlayer = state.players[state.turnIndex];
        const isMyTurn = currentPlayer.sid === socket.id;
        
        setStatus(isMyTurn ? "당신의 턴입니다!" : `${currentPlayer.name}의 턴입니다.`);
        playerInput.disabled = !isMyTurn;
        sendBtn.disabled = !isMyTurn;
    });

    socket.on('error', (data) => {
        alert(data.message);
        if (state.mode === 'multi' && !state.players.length) {
            state.roomCode = null;
        }
    });

    // Helper Functions
    function enterWaitingRoom() {
        pageMultiplayer.classList.add("hidden");
        pageWaitingRoom.classList.remove("hidden");
        displayRoomCode.textContent = state.roomCode;
        renderPlayerList();
        renderSelfInfo();
        renderCompanionsInfo();
        
        if (state.isHost) {
            hostControls.classList.remove("hidden");
        } else {
            hostControls.classList.add("hidden");
        }
    }

    function renderPlayerList() {
        playerList.innerHTML = state.players.map(p => {
            const isMe = p.sid === socket.id;
            return `
            <div class="flex items-center justify-between rounded-2xl border border-white/10 bg-surface-dark/40 p-4">
                <div class="flex items-center gap-3">
                    <div class="h-10 w-10 rounded-full bg-gradient-to-br from-primary to-purple-600 flex items-center justify-center font-bold text-white">
                        ${p.name[0]}
                    </div>
                    <div>
                        <p class="font-bold text-white">${p.name} ${isMe ? "(나)" : ""}</p>
                        <p class="text-xs text-text-secondary">${p.character ? p.character.name : "캐릭터 생성 중..."}</p>
                    </div>
                </div>
                <div class="px-3 py-1 rounded-full text-xs font-semibold ${p.is_ready ? "bg-emerald-500/20 text-emerald-300" : "bg-slate-500/20 text-slate-400"}">
                    ${p.is_ready ? "준비됨" : "대기중"}
                </div>
            </div>
            `;
        }).join("");
        
        if (state.isHost) {
            const allReady = state.players.every(p => p.is_ready);
            btnStartMultiGame.disabled = !allReady;
            btnStartMultiGame.classList.toggle("opacity-50", !allReady);
            btnStartMultiGame.classList.toggle("cursor-not-allowed", !allReady);
        }
    }
    
    async function startMultiplayerSession() {
        const scenario = state.currentScenario || (state.longPrompt ? "프롬프트 기반 시나리오" : "기본 시나리오");
        
        const allChars = state.players.map(p => p.character).filter(Boolean);
        const characterSummary = buildCharacterSummary(allChars);
        
        state.history = [{ role: "system", content: getSystemPrompt(state.players.length) }];
        state.history.push({ role: "user", content: `플레이어 캐릭터 정보:\n${characterSummary}` });
        state.history.push({ role: "user", content: `게임에 사용할 시나리오:\n${scenario}` });
        
        const opening = `플레이어 ${state.players.length}명 기준으로 아래 시나리오와 캐릭터 정보를 반영해 첫 장면을 전개해 주세요.\n${scenario}`;
        
        socket.emit('gm_response', { code: state.roomCode, content: `[게임 시작]\n${scenario}\n\nGM이 오프닝을 작성 중입니다...` });
        
        handleMultiplayerGM(opening, "System");
    }
    
    async function handleMultiplayerGM(userText, senderName) {
        const apiKey = state.apiKey;
        const model = state.model;
        
        const payloadMessages = [...state.history];
        if (senderName !== "System") {
             payloadMessages.push({ role: "user", content: `${senderName}: ${userText}` });
        } else {
             payloadMessages.push({ role: "user", content: userText });
        }

        // setBusyState(true); // Don't block UI for Host in multi
        
        try {
            const provider = state.provider;
            const reply = provider === "gemini"
              ? await requestGemini(payloadMessages, model, apiKey)
              : await requestOpenAI(payloadMessages, model, apiKey);
            
            state.history = [...payloadMessages, { role: "assistant", content: reply }];
            
            socket.emit('gm_response', { code: state.roomCode, content: reply });
            socket.emit('next_turn', { code: state.roomCode });
            
        } catch (error) {
            socket.emit('gm_response', { code: state.roomCode, content: `(GM 오류: ${error.message})` });
        }
    }

    // 초기 UI 세팅
    renderCharacterForms(Number(characterCountInput.value) || 1);
    setScenario(state.currentScenario || (state.longPrompt ? "프롬프트 기반 시나리오" : "기본 시나리오"));
    updateControlLocks();
  </script>
</body>

</html>
